{"version":3,"sources":["plugin.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst mkdirp = require(\"mkdirp\");\nconst util = require(\"util\");\nconst opn = require(\"opn\");\nconst SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nconst writeFileAsync = util.promisify(fs.writeFile);\nconst mkdirpAsync = util.promisify(mkdirp);\n\nconst readFont = (type = \"woff\", weight = 700) => {\n  const fonts = path.join(require.resolve(\"typeface-oswald\"), \"../files/\");\n  return fs.readFileSync(path.join(fonts, `./oswald-latin-${weight}.${type}`));\n};\n\nconst cssString = fs.readFileSync(path.join(__dirname, \"lib\", \"./style.css\"), \"utf8\");\nconst jsString = fs.readFileSync(path.join(__dirname, \"lib\", \"./pluginmain.js\"), \"utf8\");\nconst fontWeight = 500;\nconst fontface = buildFontface(\"Oswald\", fontWeight, {\n  woff: readFont(\"woff\", fontWeight).toString(\"base64\"),\n  woff2: readFont(\"woff2\", fontWeight).toString(\"base64\")\n});\n\nconst PLUGIN_PREFIX = \"\\u0000\";\n\nmodule.exports = function(opts) {\n  opts = opts || {};\n  const filename = opts.filename || \"stats.html\";\n  const title = opts.title || \"RollUp Visualizer\";\n  const useSourceMap = !!opts.sourcemap;\n  const open = !!opts.open;\n  const openOptions = opts.openOptions || {};\n\n  return {\n    async generateBundle(outputOptions, outputBundle) {\n      const roots = [];\n\n      for (const [id, bundle] of Object.entries(outputBundle)) {\n        //console.log(id, bundle);\n        if (bundle.isAsset) continue; //only chunks\n\n        if (useSourceMap) {\n          await addMinifiedSizesToModules(bundle);\n        }\n        const root = buildTree(bundle, useSourceMap);\n\n        flattenTree(root);\n        roots.push({ id, root });\n      }\n      const html = buildHtml(title, roots, filename);\n      await writeFile(filename, html);\n      if (open) {\n        return opn(filename, openOptions);\n      }\n    }\n  };\n};\n\nfunction buildTree(bundle, useSourceMap) {\n  const root = {\n    name: \"root\",\n    children: []\n  };\n  Object.keys(bundle.modules).forEach(id => {\n    const module = bundle.modules[id];\n    const name = id;\n    const m = {\n      size: useSourceMap ? module.minifiedSize || 0 : module.renderedLength,\n      originalSize: module.originalLength\n    };\n\n    if (name.indexOf(PLUGIN_PREFIX) === 0) {\n      addToPath(root, [name], m);\n    } else {\n      addToPath(root, name.split(path.sep), m);\n    }\n  });\n  return root;\n}\n\nfunction buildHtml(title, root) {\n  return `<!doctype html>\n      <title>${title}</title>\n      <meta charset=\"utf-8\">\n      <style>${cssString}\\n${fontface}</style>\n      <div>\n      <div>\n          <h1>${title}</h1>\n\n          <div id=\"charts\">\n          </div>\n      </div>\n      </div>\n      <script>window.nodesData = ${JSON.stringify(root)};</script>\n      <script charset=\"UTF-8\">\n        ${jsString}\n      </script>\n  `;\n}\n\nfunction buildFontface(name, weight, { woff2, woff }) {\n  return `\n    @font-face {\n      font-family: '${name}';\n      font-display: swap;\n      font-style: normal;\n      font-weight: ${weight};\n      src:\n        url(data:font/woff2;charset=utf-8;base64,${woff2}) format('woff2'),\n        url(data:application/font-woff;charset=utf-8;base64,${woff}) format('woff');\n    }`;\n}\n\nasync function writeFile(filename, contents) {\n  await mkdirpAsync(path.dirname(filename));\n  return await writeFileAsync(filename, contents);\n}\n\nfunction getDeepMoreThenOneChild(tree) {\n  if (tree.children && tree.children.length === 1) {\n    return getDeepMoreThenOneChild(tree.children[0]);\n  }\n  return tree;\n}\n\n// if root children have only on child we can flatten this\nfunction flattenTree(root) {\n  let newChildren = [];\n  root.children.forEach(child => {\n    const commonParent = getDeepMoreThenOneChild(child);\n    if (commonParent.children.length === 0) {\n      newChildren.push(commonParent);\n    } else {\n      newChildren = newChildren.concat(commonParent.children);\n    }\n  });\n  root.children = newChildren;\n}\n\nfunction addToPath(tree, p, value) {\n  if (p[0] === \"\") {\n    p.shift();\n  }\n\n  let child = tree.children.filter(c => c.name === p[0])[0];\n  if (!child) {\n    child = {\n      name: p[0],\n      children: []\n    };\n    tree.children.push(child);\n  }\n  if (p.length === 1) {\n    Object.assign(child, value);\n    return;\n  }\n  p.shift();\n  addToPath(child, p, value);\n}\n\nfunction getBytesPerFileUsingSourceMap(code, map) {\n  const lines = code.split(/[\\r\\n]/);\n\n  const bytesPerFile = {};\n\n  // For every byte in the minified code, do a sourcemap lookup.\n  for (let line = 0; line < lines.length; line++) {\n    for (let col = 0; col < lines[line].length; col++) {\n      const result = map.originalPositionFor({ line: line + 1, column: col });\n      const source = result.source || \"root\";\n      if (!bytesPerFile[source]) {\n        bytesPerFile[source] = 0;\n      }\n      bytesPerFile[source]++;\n    }\n  }\n  return Object.keys(bytesPerFile).map(file => ({\n    file: path.resolve(file),\n    bytes: bytesPerFile[file]\n  }));\n}\n\n// Given a file C:/path/to/file/on/filesystem.js\n// - remove extension\n// - strip filesystem root\n// - return path segments, starting from the tail and working backwards\n// segments('C:/path/to/file/on/filesystem.js') === ['filesystem', 'on', 'file', 'to', 'path']\nfunction segments(filepath) {\n  const parsed = path.parse(filepath);\n  const dirWithoutRoot = parsed.dir.substring(parsed.root.length);\n\n  return dirWithoutRoot\n    .split(path.sep)\n    .concat(parsed.name)\n    .reverse();\n}\n\n// Adds a .minifiedSize property to each module in the bundle (using sourcemap data)\n// If the minified size could not be computed, no property is added.\n// Module id are mapped to sources by finding the best match.\n// Matching is done by removing the file extensions and comparing path segments\nfunction addMinifiedSizesToModules(bundle) {\n  const findBestMatchingModule = filename => {\n    const filenameSegments = segments(filename);\n\n    for (let i = 1; i <= filenameSegments.length; i++) {\n      const leftVals = filenameSegments.slice(0, i);\n\n      const matches = Object.keys(bundle.modules).filter(id => {\n        const moduleSegments = segments(id);\n        const rightVals = moduleSegments.slice(0, i);\n        if (rightVals.length !== leftVals.length) {\n          return false;\n        }\n        return rightVals.every((rightVal, i) => rightVal === leftVals[i]);\n      });\n\n      if (matches.length === 1) {\n        return bundle.modules[matches[0]];\n      }\n    }\n\n    return null;\n  };\n\n  return SourceMapConsumer.with(bundle.map, null, map => {\n    const fileSizes = getBytesPerFileUsingSourceMap(bundle.code, map);\n    fileSizes.forEach(tuple => {\n      const module = findBestMatchingModule(tuple.file);\n      if (module) {\n        module.minifiedSize = tuple.bytes;\n      }\n    });\n  });\n}\n"]}