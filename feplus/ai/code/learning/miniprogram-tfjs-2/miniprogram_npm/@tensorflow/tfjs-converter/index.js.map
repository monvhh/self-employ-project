{"version":3,"sources":["index.js","executor/graph_model.js","operations/operation_mapper.js","data/compiled_api.js","operations/custom_op/register.js","operations/executors/utils.js","operations/op_list/arithmetic.js","operations/op_list/basic_math.js","operations/op_list/control.js","operations/op_list/convolution.js","operations/op_list/creation.js","operations/op_list/dynamic.js","operations/op_list/evaluation.js","operations/op_list/graph.js","operations/op_list/image.js","operations/op_list/logical.js","operations/op_list/matrices.js","operations/op_list/normalization.js","operations/op_list/reduction.js","operations/op_list/slice_join.js","operations/op_list/spectral.js","operations/op_list/transformation.js","executor/graph_executor.js","operations/operation_executor.js","operations/custom_op/node_value_impl.js","operations/executors/arithmetic_executor.js","operations/executors/basic_math_executor.js","operations/executors/control_executor.js","executor/tensor_array.js","operations/executors/convolution_executor.js","operations/executors/creation_executor.js","operations/executors/dynamic_executor.js","operations/executors/evaluation_executor.js","operations/executors/graph_executor.js","operations/executors/image_executor.js","operations/executors/logical_executor.js","operations/executors/matrices_executor.js","operations/executors/normalization_executor.js","operations/executors/reduction_executor.js","operations/executors/slice_join_executor.js","operations/executors/spectral_executor.js","operations/executors/transformation_executor.js","executor/execution_context.js","executor/model_analysis.js","version.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AENA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,AFMA;ACFA,AFMA,ADGA,AIZA,ACHA,AHSA;ACFA,AFMA,ADGA,AIZA,ACHA,AHSA;ACFA,AFMA,ADGA,AIZA,ACHA,AHSA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,AJYA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,AJYA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,AJYA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ALeA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ALeA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ALeA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ACHA,ANkBA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ACHA,ANkBA;ACFA,AFMA,ADGA,AIZA,ACHA,ACHA,ACHA,ACHA,ANkBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhBgDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjBmDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjBmDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjBmDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlBsDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlBsDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlBsDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AFMA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnByDA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;ACFA,AmBzDA,ArB+DA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ApB4DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ArB+DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ArB+DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ArB+DA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,AuBrEA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ApB4DA,AqB/DA,ACHA,ACHA,AtBkEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,AxBwEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,AxBwEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,AxBwEA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,AzB2EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,AzB2EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,AzB2EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,A1B8EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,A1B8EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,A1B8EA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,A3BiFA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,A3BiFA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,A3BiFA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,A5BoFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,A5BoFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,A5BoFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A7BuFA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A9B0FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/B6FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/B6FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A/B6FA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AhCgGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjCmGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlCsGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AoB3DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA,A0C9HA;AFOA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AGTA,AENA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,ACHA,ACHA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AENA,ACHA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AENA,AGTA,ACHA,ACHA,ACHA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AENA,AGTA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AENA,AGTA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AENA,AGTA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AJYA,AENA,ACHA,AGTA,ACHA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AENA,ArB+DA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AGTA,ACHA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AENA,AKfA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AKfA,AENA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,ACHA,ACHA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AIZA,AOrBA,ACHA,AENA,AnCyGA,ACHA,ACHA,AENA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AWjCA,ACHA,AENA,AnCyGA,ACHA,ACHA,AENA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AWjCA,ACHA,AENA,AnCyGA,ACHA,ACHA,AENA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AWjCA,ACHA,AhCgGA,ACHA,AENA,AOrBA,AENA,AENA,AnByDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,AFMA,ACHA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AENA,AOrBA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AS3BA,AENA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AWjCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AWjCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AWjCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,ACHA,AWjCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A0C9HA,Af6CA,ADGA,AYpCA,AhCgGA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ADGA,ApB4DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AwCvHA,ApB4DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,AYpCA,AjBmDA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,A2BjFA,ArB+DA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA,ALeA;AoB3DA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,ArB+DA,AMlBA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA,Af6CA;Ae5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar graph_model_1 = require(\"./executor/graph_model\");\nexports.GraphModel = graph_model_1.GraphModel;\nexports.loadGraphModel = graph_model_1.loadGraphModel;\nvar register_1 = require(\"./operations/custom_op/register\");\nexports.deregisterOp = register_1.deregisterOp;\nexports.registerOp = register_1.registerOp;\nvar version_1 = require(\"./version\");\nexports.version_converter = version_1.version;\n//# sourceMappingURL=index.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar operation_mapper_1 = require(\"../operations/operation_mapper\");\nvar graph_executor_1 = require(\"./graph_executor\");\nexports.TFHUB_SEARCH_PARAM = '?tfjs-format=file';\nexports.DEFAULT_MODEL_NAME = 'model.json';\n/**\n * A `tf.GraphModel` is a directed, acyclic graph of built from\n * SavedModel GraphDef and allows inference exeuction.\n *\n * A `tf.GraphModel` can only be created by loading from a model converted from\n * a [TensorFlow SavedModel](https://www.tensorflow.org/guide/saved_model) using\n * the command line converter tool and loaded via `tf.loadGraphModel`.\n */\n/** @doc {heading: 'Models', subheading: 'Classes'} */\nvar GraphModel = /** @class */ (function () {\n    /**\n     * @param modelUrl url for the model, or an `io.IOHandler`.\n     * @param weightManifestUrl url for the weight file generated by\n     * scripts/convert.py script.\n     * @param requestOption options for Request, which allows to send credentials\n     * and custom headers.\n     * @param onProgress Optional, progress callback function, fired periodically\n     * before the load is completed.\n     */\n    function GraphModel(modelUrl, loadOptions) {\n        if (loadOptions === void 0) { loadOptions = {}; }\n        this.modelUrl = modelUrl;\n        this.loadOptions = loadOptions;\n        this.version = 'n/a';\n        if (loadOptions == null) {\n            this.loadOptions = {};\n        }\n    }\n    Object.defineProperty(GraphModel.prototype, \"modelVersion\", {\n        // Returns the version information for the tensorflow model GraphDef.\n        get: function () {\n            return this.version;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"inputNodes\", {\n        get: function () {\n            return this.executor.inputNodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"outputNodes\", {\n        get: function () {\n            return this.executor.outputNodes;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"inputs\", {\n        get: function () {\n            return this.executor.inputs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"outputs\", {\n        get: function () {\n            return this.executor.outputs;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphModel.prototype, \"weights\", {\n        get: function () {\n            return this.executor.weightMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphModel.prototype.findIOHandler = function () {\n        var path = this.modelUrl;\n        if (path.load != null) {\n            // Path is an IO Handler.\n            this.handler = path;\n        }\n        else if (this.loadOptions.requestInit != null) {\n            this.handler = tfjs_core_1.io.browserHTTPRequest(path, this.loadOptions);\n        }\n        else {\n            var handlers = tfjs_core_1.io.getLoadHandlers(path, this.loadOptions.onProgress);\n            if (handlers.length === 0) {\n                // For backward compatibility: if no load handler can be found,\n                // assume it is a relative http path.\n                handlers.push(tfjs_core_1.io.browserHTTPRequest(path, this.loadOptions));\n            }\n            else if (handlers.length > 1) {\n                throw new Error(\"Found more than one (\" + handlers.length + \") load handlers for \" +\n                    (\"URL '\" + [path] + \"'\"));\n            }\n            this.handler = handlers[0];\n        }\n    };\n    /**\n     * Loads the model and weight files, construct the in memory weight map and\n     * compile the inference graph.\n     */\n    GraphModel.prototype.load = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var artifacts, graph, weightMap;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.findIOHandler();\n                        if (this.handler.load == null) {\n                            throw new Error('Cannot proceed with model loading because the IOHandler provided ' +\n                                'does not have the `load` method implemented.');\n                        }\n                        return [4 /*yield*/, this.handler.load()];\n                    case 1:\n                        artifacts = _a.sent();\n                        graph = artifacts.modelTopology;\n                        this.version = graph.versions.producer + \".\" + graph.versions.minConsumer;\n                        weightMap = tfjs_core_1.io.decodeWeights(artifacts.weightData, artifacts.weightSpecs);\n                        this.executor =\n                            new graph_executor_1.GraphExecutor(operation_mapper_1.OperationMapper.Instance.transformGraph(graph));\n                        this.executor.weightMap = this.convertTensorMapToTensorsMap(weightMap);\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    /**\n     * Execute the inference for the input tensors.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a `tf.Tensor`. For models with mutliple inputs,\n     * inputs params should be in either `tf.Tensor`[] if the input order is\n     * fixed, or otherwise NamedTensorMap format.\n     *\n     * For model with multiple inputs, we recommend you use NamedTensorMap as the\n     * input type, if you use `tf.Tensor`[], the order of the array needs to\n     * follow the\n     * order of inputNodes array. @see {@link GraphModel.inputNodes}\n     *\n     * You can also feed any intermediate nodes using the NamedTensorMap as the\n     * input type. For example, given the graph\n     *    InputNode => Intermediate => OutputNode,\n     * you can execute the subgraph Intermediate => OutputNode by calling\n     *    model.execute('IntermediateNode' : tf.tensor(...));\n     *\n     * This is useful for models that uses tf.dynamic_rnn, where the intermediate\n     * state needs to be fed manually.\n     *\n     * For batch inference execution, the tensors for each input need to be\n     * concatenated together. For example with mobilenet, the required input shape\n     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n     * If we are provide a batched data of 100 images, the input tensor should be\n     * in the shape of [100, 244, 244, 3].\n     *\n     * @param config Prediction configuration for specifying the batch size and\n     * output node names. Currently the batch size option is ignored for graph\n     * model.\n     *\n     * @returns Inference result tensors. The output would be single `tf.Tensor`\n     * if model has single output node, otherwise Tensor[] or NamedTensorMap[]\n     * will be returned for model with multiple outputs.\n     */\n    /** @doc {heading: 'Models', subheading: 'Classes'} */\n    GraphModel.prototype.predict = function (inputs, config) {\n        return this.execute(inputs, this.outputNodes);\n    };\n    GraphModel.prototype.normalizeInputs = function (inputs) {\n        if (!(inputs instanceof tfjs_core_1.Tensor) && !Array.isArray(inputs)) {\n            // The input is already a NamedTensorMap.\n            return inputs;\n        }\n        inputs = Array.isArray(inputs) ? inputs : [inputs];\n        if (inputs.length !== this.inputNodes.length) {\n            throw new Error('Input tensor count mismatch,' +\n                (\"the graph model has \" + this.inputNodes.length + \" placeholders, \") +\n                (\"while there are \" + inputs.length + \" input tensors.\"));\n        }\n        return this.inputNodes.reduce(function (map, inputName, i) {\n            map[inputName] = inputs[i];\n            return map;\n        }, {});\n    };\n    GraphModel.prototype.normalizeOutputs = function (outputs) {\n        outputs = outputs || this.outputNodes;\n        return !Array.isArray(outputs) ? [outputs] : outputs;\n    };\n    /**\n     * Executes inference for the model for given input tensors.\n     * @param inputs tensor, tensor array or tensor map of the inputs for the\n     * model, keyed by the input node names.\n     * @param outputs output node name from the Tensorflow model, if no\n     * outputs are specified, the default outputs of the model would be used.\n     * You can inspect intermediate nodes of the model by adding them to the\n     * outputs array.\n     *\n     * @returns A single tensor if provided with a single output or no outputs\n     * are provided and there is only one default output, otherwise return a\n     * tensor array. The order of the tensor array is the same as the outputs\n     * if provided, otherwise the order of outputNodes attribute of the model.\n     */\n    /** @doc {heading: 'Models', subheading: 'Classes'} */\n    GraphModel.prototype.execute = function (inputs, outputs) {\n        inputs = this.normalizeInputs(inputs);\n        outputs = this.normalizeOutputs(outputs);\n        var result = this.executor.execute(inputs, outputs);\n        return result.length > 1 ? result : result[0];\n    };\n    /**\n     * Executes inference for the model for given input tensors in async\n     * fashion, use this method when your model contains control flow ops.\n     * @param inputs tensor, tensor array or tensor map of the inputs for the\n     * model, keyed by the input node names.\n     * @param outputs output node name from the Tensorflow model, if no outputs\n     * are specified, the default outputs of the model would be used. You can\n     * inspect intermediate nodes of the model by adding them to the outputs\n     * array.\n     *\n     * @returns A Promise of single tensor if provided with a single output or\n     * no outputs are provided and there is only one default output, otherwise\n     * return a tensor map.\n     */\n    /** @doc {heading: 'Models', subheading: 'Classes'} */\n    GraphModel.prototype.executeAsync = function (inputs, outputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        inputs = this.normalizeInputs(inputs);\n                        outputs = this.normalizeOutputs(outputs);\n                        return [4 /*yield*/, this.executor.executeAsync(inputs, outputs)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, result.length > 1 ? result : result[0]];\n                }\n            });\n        });\n    };\n    GraphModel.prototype.convertTensorMapToTensorsMap = function (map) {\n        return Object.keys(map).reduce(function (newMap, key) {\n            newMap[key] = [map[key]];\n            return newMap;\n        }, {});\n    };\n    /**\n     * Releases the memory used by the weight tensors.\n     */\n    /** @doc {heading: 'Models', subheading: 'Classes'} */\n    GraphModel.prototype.dispose = function () {\n        this.executor.dispose();\n    };\n    return GraphModel;\n}());\nexports.GraphModel = GraphModel;\n/**\n * Load a graph model given a URL to the model definition.\n *\n * Example of loading MobileNetV2 from a URL and making a prediction with a\n * zeros input:\n *\n * ```js\n * const modelUrl =\n *    'https://storage.googleapis.com/tfjs-models/savedmodel/mobilenet_v2_1.0_224/model.json';\n * const model = await tf.loadGraphModel(modelUrl);\n * const zeros = tf.zeros([1, 224, 224, 3]);\n * model.predict(zeros).print();\n * ```\n *\n * Example of loading MobileNetV2 from a TF Hub URL and making a prediction with\n * a zeros input:\n *\n * ```js\n * const modelUrl =\n *    'https://tfhub.dev/google/imagenet/mobilenet_v2_140_224/classification/2';\n * const model = await tf.loadGraphModel(modelUrl, {fromTFHub: true});\n * const zeros = tf.zeros([1, 224, 224, 3]);\n * model.predict(zeros).print();\n * ```\n * @param modelUrl The url or an `io.IOHandler` that loads the model.\n * @param options Options for the HTTP request, which allows to send credentials\n *    and custom headers.\n */\n/** @doc {heading: 'Models', subheading: 'Loading'} */\nfunction loadGraphModel(modelUrl, options) {\n    if (options === void 0) { options = {}; }\n    return __awaiter(this, void 0, void 0, function () {\n        var model;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (modelUrl == null) {\n                        throw new Error('modelUrl in loadGraphModel() cannot be null. Please provide a url ' +\n                            'or an IOHandler that loads the model');\n                    }\n                    if (options == null) {\n                        options = {};\n                    }\n                    if (options.fromTFHub) {\n                        if (modelUrl.load == null) {\n                            if (!modelUrl.endsWith('/')) {\n                                modelUrl = modelUrl + '/';\n                            }\n                            modelUrl = \"\" + modelUrl + exports.DEFAULT_MODEL_NAME + exports.TFHUB_SEARCH_PARAM;\n                        }\n                    }\n                    model = new GraphModel(modelUrl, options);\n                    return [4 /*yield*/, model.load()];\n                case 1:\n                    _a.sent();\n                    return [2 /*return*/, model];\n            }\n        });\n    });\n}\nexports.loadGraphModel = loadGraphModel;\n//# sourceMappingURL=graph_model.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar tensorflow = require(\"../data/compiled_api\");\nvar register_1 = require(\"./custom_op/register\");\nvar utils_1 = require(\"./executors/utils\");\nvar arithmetic = require(\"./op_list/arithmetic\");\nvar basicMath = require(\"./op_list/basic_math\");\nvar control = require(\"./op_list/control\");\nvar convolution = require(\"./op_list/convolution\");\nvar creation = require(\"./op_list/creation\");\nvar dynamic = require(\"./op_list/dynamic\");\nvar evaluation = require(\"./op_list/evaluation\");\nvar graph = require(\"./op_list/graph\");\nvar image = require(\"./op_list/image\");\nvar logical = require(\"./op_list/logical\");\nvar matrices = require(\"./op_list/matrices\");\nvar normalization = require(\"./op_list/normalization\");\nvar reduction = require(\"./op_list/reduction\");\nvar sliceJoin = require(\"./op_list/slice_join\");\nvar spectral = require(\"./op_list/spectral\");\nvar transformation = require(\"./op_list/transformation\");\nvar OperationMapper = /** @class */ (function () {\n    // Loads the op mapping from the JSON file.\n    function OperationMapper() {\n        var ops = [\n            arithmetic, basicMath, control, convolution, creation, dynamic,\n            evaluation, logical, image, graph, matrices, normalization, reduction,\n            sliceJoin, spectral, transformation\n        ];\n        var mappersJson = [].concat.apply([], ops.map(function (op) { return op.json; }));\n        this.opMappers = mappersJson.reduce(function (map, mapper) {\n            map[mapper.tfOpName] = mapper;\n            return map;\n        }, {});\n    }\n    Object.defineProperty(OperationMapper, \"Instance\", {\n        // Singleton instance for the mapper\n        get: function () {\n            return this._instance || (this._instance = new this());\n        },\n        enumerable: true,\n        configurable: true\n    });\n    // Converts the model from Tensorflow GraphDef to local representation for\n    // TensorFlow.js API\n    OperationMapper.prototype.transformGraph = function (graph) {\n        var _this = this;\n        var tfNodes = graph.node;\n        var placeholders = [];\n        var weights = [];\n        var nodes = tfNodes.reduce(function (map, node) {\n            map[node.name] = _this.mapNode(node);\n            if (node.op === 'Placeholder') {\n                placeholders.push(map[node.name]);\n            }\n            if (node.op === 'Const') {\n                weights.push(map[node.name]);\n            }\n            return map;\n        }, {});\n        var inputs = [];\n        var outputs = [];\n        var allNodes = Object.keys(nodes);\n        allNodes.forEach(function (key) {\n            var node = nodes[key];\n            node.inputNames.forEach(function (name) {\n                var nodeName = utils_1.getNodeNameAndIndex(name)[0];\n                node.inputs.push(nodes[nodeName]);\n                nodes[nodeName].children.push(node);\n            });\n            if (node.inputs.length === 0)\n                inputs.push(node);\n        });\n        allNodes.forEach(function (key) {\n            var node = nodes[key];\n            if (node.children.length === 0)\n                outputs.push(node);\n        });\n        return { nodes: nodes, inputs: inputs, outputs: outputs, weights: weights, placeholders: placeholders };\n    };\n    OperationMapper.prototype.mapNode = function (node) {\n        // Unsupported ops will cause an error at run-time (not parse time), since\n        // they may not be used by the actual execution subgraph.\n        var mapper = register_1.getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n        if (node.attr == null) {\n            node.attr = {};\n        }\n        var newNode = {\n            name: node.name,\n            op: node.op,\n            category: mapper.category,\n            inputNames: (node.input ||\n                []).map(function (input) { return input.startsWith('^') ? input.substr(1) : input; }),\n            inputs: [],\n            children: [],\n            inputParams: {},\n            attrParams: {},\n            rawAttrs: node.attr\n        };\n        if (mapper.inputs != null) {\n            newNode.inputParams =\n                mapper.inputs.reduce(function (map, param) {\n                    map[param.name] = {\n                        type: param.type,\n                        inputIndexStart: param.start,\n                        inputIndexEnd: param.end\n                    };\n                    return map;\n                }, {});\n        }\n        if (mapper.attrs != null) {\n            newNode.attrParams =\n                mapper.attrs.reduce(function (map, param) {\n                    var type = param.type;\n                    var value = undefined;\n                    switch (param.type) {\n                        case 'string':\n                            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'string[]':\n                            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number':\n                            value = getNumberParam(node.attr, param.tfName, (param.defaultValue || 0));\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'number[]':\n                            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool':\n                            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'bool[]':\n                            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape':\n                            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'shape[]':\n                            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype':\n                            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'dtype[]':\n                            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n                            if (value === undefined && !!param.tfDeprecatedName) {\n                                value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n                            }\n                            break;\n                        case 'tensor':\n                        case 'tensors':\n                            break;\n                        default:\n                            throw new Error(\"Unsupported param type: \" + param.type + \" for op: \" + node.op);\n                    }\n                    map[param.name] = { value: value, type: type };\n                    return map;\n                }, {});\n        }\n        return newNode;\n    };\n    return OperationMapper;\n}());\nexports.OperationMapper = OperationMapper;\nfunction decodeBase64(text) {\n    // tslint:disable-next-line:no-any\n    var global = tfjs_core_1.ENV.global;\n    if (typeof global.atob !== 'undefined') {\n        return global.atob(text);\n    }\n    else if (typeof Buffer !== 'undefined') {\n        return new Buffer(text, 'base64').toString();\n    }\n    else {\n        throw new Error('Unable to decode base64 in this environment. ' +\n            'Missing built-in atob() or Buffer()');\n    }\n}\nexports.decodeBase64 = decodeBase64;\nfunction parseStringParam(s, keepCase) {\n    var value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n    return keepCase ? value : value.toLowerCase();\n}\nexports.parseStringParam = parseStringParam;\nfunction getStringParam(attrs, name, def, keepCase) {\n    if (keepCase === void 0) { keepCase = false; }\n    var param = attrs[name];\n    if (param != null) {\n        return parseStringParam(param.s, keepCase);\n    }\n    return def;\n}\nexports.getStringParam = getStringParam;\nfunction getBoolParam(attrs, name, def) {\n    var param = attrs[name];\n    return param ? param.b : def;\n}\nexports.getBoolParam = getBoolParam;\nfunction getNumberParam(attrs, name, def) {\n    var param = attrs[name] || {};\n    var value = param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n    return (typeof value === 'number') ? value :\n        parseInt(value, 10);\n}\nexports.getNumberParam = getNumberParam;\nfunction parseDtypeParam(value) {\n    if (typeof (value) === 'string') {\n        // tslint:disable-next-line:no-any\n        value = tensorflow.DataType[value];\n    }\n    switch (value) {\n        case tensorflow.DataType.DT_FLOAT:\n            return 'float32';\n        case tensorflow.DataType.DT_INT32:\n            return 'int32';\n        case tensorflow.DataType.DT_BOOL:\n            return 'bool';\n        case tensorflow.DataType.DT_DOUBLE:\n            return 'float32';\n        case tensorflow.DataType.DT_STRING:\n            return 'string';\n        default:\n            // Unknown dtype error will happen at runtime (instead of parse time),\n            // since these nodes might not be used by the actual subgraph execution.\n            return null;\n    }\n}\nexports.parseDtypeParam = parseDtypeParam;\nfunction getDtypeParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.type) {\n        return parseDtypeParam(param.type);\n    }\n    return def;\n}\nexports.getDtypeParam = getDtypeParam;\nfunction getDtypeArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.type) {\n        return param.list.type.map(function (v) { return parseDtypeParam(v); });\n    }\n    return def;\n}\nexports.getDtypeArrayParam = getDtypeArrayParam;\nfunction parseTensorShapeParam(shape) {\n    if (shape.unknownRank) {\n        return undefined;\n    }\n    if (shape.dim != null) {\n        return shape.dim.map(function (dim) { return (typeof dim.size === 'number') ?\n            dim.size :\n            parseInt(dim.size, 10); });\n    }\n    return [];\n}\nexports.parseTensorShapeParam = parseTensorShapeParam;\nfunction getTensorShapeParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.shape) {\n        return parseTensorShapeParam(param.shape);\n    }\n    return def;\n}\nexports.getTensorShapeParam = getTensorShapeParam;\nfunction getNumericArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param) {\n        return ((param.list.f && param.list.f.length ? param.list.f : param.list.i))\n            .map(function (v) { return (typeof v === 'number') ? v :\n            parseInt(v, 10); });\n    }\n    return def;\n}\nexports.getNumericArrayParam = getNumericArrayParam;\nfunction getStringArrayParam(attrs, name, def, keepCase) {\n    if (keepCase === void 0) { keepCase = false; }\n    var param = attrs[name];\n    if (param && param.list && param.list.s) {\n        return param.list.s.map(function (v) {\n            return parseStringParam(v, keepCase);\n        });\n    }\n    return def;\n}\nexports.getStringArrayParam = getStringArrayParam;\nfunction getTensorShapeArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.shape) {\n        return param.list.shape.map(function (v) {\n            return parseTensorShapeParam(v);\n        });\n    }\n    return def;\n}\nexports.getTensorShapeArrayParam = getTensorShapeArrayParam;\nfunction getBoolArrayParam(attrs, name, def) {\n    var param = attrs[name];\n    if (param && param.list && param.list.b) {\n        return param.list.b;\n    }\n    return def;\n}\nexports.getBoolArrayParam = getBoolArrayParam;\n//# sourceMappingURL=operation_mapper.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** DataType enum. */\nvar DataType;\n(function (DataType) {\n    DataType[DataType[\"DT_INVALID\"] = 0] = \"DT_INVALID\";\n    DataType[DataType[\"DT_FLOAT\"] = 1] = \"DT_FLOAT\";\n    DataType[DataType[\"DT_DOUBLE\"] = 2] = \"DT_DOUBLE\";\n    DataType[DataType[\"DT_INT32\"] = 3] = \"DT_INT32\";\n    DataType[DataType[\"DT_UINT8\"] = 4] = \"DT_UINT8\";\n    DataType[DataType[\"DT_INT16\"] = 5] = \"DT_INT16\";\n    DataType[DataType[\"DT_INT8\"] = 6] = \"DT_INT8\";\n    DataType[DataType[\"DT_STRING\"] = 7] = \"DT_STRING\";\n    DataType[DataType[\"DT_COMPLEX64\"] = 8] = \"DT_COMPLEX64\";\n    DataType[DataType[\"DT_INT64\"] = 9] = \"DT_INT64\";\n    DataType[DataType[\"DT_BOOL\"] = 10] = \"DT_BOOL\";\n    DataType[DataType[\"DT_QINT8\"] = 11] = \"DT_QINT8\";\n    DataType[DataType[\"DT_QUINT8\"] = 12] = \"DT_QUINT8\";\n    DataType[DataType[\"DT_QINT32\"] = 13] = \"DT_QINT32\";\n    DataType[DataType[\"DT_BFLOAT16\"] = 14] = \"DT_BFLOAT16\";\n    DataType[DataType[\"DT_FLOAT_REF\"] = 101] = \"DT_FLOAT_REF\";\n    DataType[DataType[\"DT_DOUBLE_REF\"] = 102] = \"DT_DOUBLE_REF\";\n    DataType[DataType[\"DT_INT32_REF\"] = 103] = \"DT_INT32_REF\";\n    DataType[DataType[\"DT_UINT8_REF\"] = 104] = \"DT_UINT8_REF\";\n    DataType[DataType[\"DT_INT16_REF\"] = 105] = \"DT_INT16_REF\";\n    DataType[DataType[\"DT_INT8_REF\"] = 106] = \"DT_INT8_REF\";\n    DataType[DataType[\"DT_STRING_REF\"] = 107] = \"DT_STRING_REF\";\n    DataType[DataType[\"DT_COMPLEX64_REF\"] = 108] = \"DT_COMPLEX64_REF\";\n    DataType[DataType[\"DT_INT64_REF\"] = 109] = \"DT_INT64_REF\";\n    DataType[DataType[\"DT_BOOL_REF\"] = 110] = \"DT_BOOL_REF\";\n    DataType[DataType[\"DT_QINT8_REF\"] = 111] = \"DT_QINT8_REF\";\n    DataType[DataType[\"DT_QUINT8_REF\"] = 112] = \"DT_QUINT8_REF\";\n    DataType[DataType[\"DT_QINT32_REF\"] = 113] = \"DT_QINT32_REF\";\n    DataType[DataType[\"DT_BFLOAT16_REF\"] = 114] = \"DT_BFLOAT16_REF\";\n})(DataType = exports.DataType || (exports.DataType = {}));\nvar SaverDef;\n(function (SaverDef) {\n    /** CheckpointFormatVersion enum. */\n    var CheckpointFormatVersion;\n    (function (CheckpointFormatVersion) {\n        CheckpointFormatVersion[CheckpointFormatVersion[\"LEGACY\"] = 0] = \"LEGACY\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V1\"] = 1] = \"V1\";\n        CheckpointFormatVersion[CheckpointFormatVersion[\"V2\"] = 2] = \"V2\";\n    })(CheckpointFormatVersion = SaverDef.CheckpointFormatVersion || (SaverDef.CheckpointFormatVersion = {}));\n})(SaverDef = exports.SaverDef || (exports.SaverDef = {}));\n//# sourceMappingURL=compiled_api.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CUSTOM_OPS = {};\n/**\n * Register an Op for graph model executor. This allow you to register\n * TensorFlow custom op or override existing op.\n *\n * Here is an example of registering a new MatMul Op.\n * ```js\n * const customMatmul = (node) =>\n *    tf.matMul(\n *        node.inputs[0], node.inputs[1],\n *        node.attrs['transpose_a'], node.attrs['transpose_b']);\n *\n * tf.registerOp('MatMul', customMatmul);\n * ```\n * The inputs and attrs of the node object is based on the TensorFlow op\n * registry.\n *\n * @param name The Tensorflow Op name.\n * @param opFunc An op function which is called with the current graph node\n * during execution and needs to return a tensor or a list of tensors. The node\n * has the following attributes:\n *    - attr: A map from attribute name to its value\n *    - inputs: A list of input tensors\n */\n/** @doc {heading: 'Models', subheading: 'Op Registry'} */\nfunction registerOp(name, opFunc) {\n    var opMapper = {\n        tfOpName: name,\n        category: 'custom',\n        inputs: [],\n        attrs: [],\n        customExecutor: opFunc\n    };\n    CUSTOM_OPS[name] = opMapper;\n}\nexports.registerOp = registerOp;\n/**\n * Retrieve the OpMapper object for the registered op.\n *\n * @param name The Tensorflow Op name.\n */\n/** @doc {heading: 'Models', subheading: 'Op Registry'} */\nfunction getRegisteredOp(name) {\n    return CUSTOM_OPS[name];\n}\nexports.getRegisteredOp = getRegisteredOp;\n/**\n * Deregister the Op for graph model executor.\n *\n * @param name The Tensorflow Op name.\n */\n/** @doc {heading: 'Models', subheading: 'Op Registry'} */\nfunction deregisterOp(name) {\n    delete CUSTOM_OPS[name];\n}\nexports.deregisterOp = deregisterOp;\n//# sourceMappingURL=register.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getParamValue(paramName, node, tensorMap, context) {\n    var inputParam = node.inputParams[paramName];\n    if (inputParam && inputParam.inputIndexStart !== undefined) {\n        var start = inputParam.inputIndexStart;\n        var end = inputParam.inputIndexEnd === 0 ?\n            undefined :\n            (inputParam.inputIndexEnd === undefined ? start + 1 :\n                inputParam.inputIndexEnd);\n        if (inputParam.type === 'tensor') {\n            return getTensor(node.inputNames[inputParam.inputIndexStart], tensorMap, context);\n        }\n        if (inputParam.type === 'tensors') {\n            var inputs = node.inputNames.slice(start, end);\n            return inputs.map(function (name) { return getTensor(name, tensorMap, context); });\n        }\n        var data = Array.prototype.slice.call(getTensor(node.inputNames.slice(start)[0], tensorMap, context)\n            .dataSync());\n        return inputParam.type === 'number' ? data[0] : data;\n    }\n    var attrParam = node.attrParams[paramName];\n    return attrParam && attrParam.value;\n}\nexports.getParamValue = getParamValue;\n/**\n * Retrieve the tensor based on input name by extracting the node name and\n * output index information.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nfunction getTensor(name, tensorsMap, context) {\n    var _a = parseNodeName(name), nodeName = _a[0], index = _a[1];\n    var contextId = context.currentContextIds.find(function (contextId) {\n        return !!tensorsMap[getNodeNameWithContextId(nodeName, contextId)];\n    });\n    return contextId !== undefined ?\n        tensorsMap[getNodeNameWithContextId(nodeName, contextId)][index] :\n        undefined;\n}\nexports.getTensor = getTensor;\n/**\n * Retrieve the tensors based on input name for current context.\n * @param name Node input name\n * @param tensorsMap Tensors map keyed by the node\n */\nfunction getTensorsForCurrentContenxt(name, tensorsMap, context) {\n    return tensorsMap[getNodeNameWithContextId(name, context.currentContextId)];\n}\nexports.getTensorsForCurrentContenxt = getTensorsForCurrentContenxt;\n/**\n * Returns the node name and index from the Node input name.\n * @param inputName The input name of the node, in format of\n * node_name:output_index, i.e. MatMul:0, if the output_index is not set, it is\n * default to 0.\n */\nfunction getNodeNameAndIndex(inputName, context) {\n    var _a = parseNodeName(inputName), nodeName = _a[0], index = _a[1];\n    return [\n        getNodeNameWithContextId(nodeName, context && context.currentContextId),\n        index\n    ];\n}\nexports.getNodeNameAndIndex = getNodeNameAndIndex;\nfunction getNodeNameWithContextId(name, contextId) {\n    return !!contextId ? name + \"-\" + contextId : name;\n}\nfunction parseNodeName(name) {\n    var index = name.lastIndexOf(':');\n    if (index === -1)\n        return [name, 0];\n    var nodeName = name.substring(0, index);\n    return [nodeName, Number(name.substring(index + 1))];\n}\nexports.parseNodeName = parseNodeName;\nfunction split(arr, size) {\n    var res = [];\n    for (var i = 0; i < arr.length; i += size) {\n        res.push(arr.slice(i, i + size));\n    }\n    return res;\n}\nexports.split = split;\n//# sourceMappingURL=utils.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Add',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'AddN',\n        'category': 'arithmetic',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'BiasAdd',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sub',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'RealDiv',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Div',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'FloorDiv',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Mul',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Maximum',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'Minimum',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'Pow',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'SquaredDifference',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Mod',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'FloorMod',\n        'category': 'arithmetic',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=arithmetic.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Abs',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Acos',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Asin',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atan',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atan2',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'y', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Ceil',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ClipByValue',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'clip_value_min', 'name': 'clipValueMin', 'type': 'number' },\n            { 'tfName': 'clip_value_max', 'name': 'clipValueMax', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Complex',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'real', 'type': 'tensor' },\n            { 'start': 1, 'name': 'imag', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ComplexAbs',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Cos',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Cosh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Elu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Exp',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Floor',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Log',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Neg',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Relu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Relu6',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'clipValueMin',\n                'name': 'clipValueMin',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'clipValueMax',\n                'name': 'clipValueMax',\n                'type': 'number',\n                'defaultValue': 6\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Selu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sigmoid',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sin',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sinh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sqrt',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Rsqrt',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Square',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Tan',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Tanh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Sign',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Round',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Expm1',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Log1p',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Reciprocal',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Softplus',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Asinh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Acosh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Atanh',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Erf',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Prod',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axes', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'keep_dims',\n                'name': 'keepDims',\n                'type': 'bool',\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LeakyRelu',\n        'category': 'basic_math',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'alpha',\n                'name': 'alpha',\n                'type': 'number',\n                'defaultValue': 0.2\n            },\n            {\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }\n        ]\n    }\n];\n//# sourceMappingURL=basic_math.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'LoopCond',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'name': 'pred', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Switch',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'data', 'type': 'tensor' },\n            { 'start': 1, 'name': 'pred', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'Merge',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Enter',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'frame_name', 'name': 'frameName', 'type': 'string' },\n            { 'tfName': 'is_constant', 'name': 'isConstant', 'type': 'bool' }\n        ]\n    },\n    {\n        'tfOpName': 'Exit',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'NextIteration',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'size', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'element_shape', 'name': 'elementShape', 'type': 'shape' },\n            { 'tfName': 'dynamic_size', 'name': 'dynamicSize', 'type': 'bool' },\n            { 'tfName': 'clear_after_read', 'name': 'clearAfterRead', 'type': 'bool' },\n            {\n                'tfName': 'identical_element_shapes',\n                'name': 'identicalElementShapes',\n                'type': 'bool'\n            },\n            { 'tfName': 'tensor_array_name', 'name': 'name', 'type': 'string' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayWriteV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayReadV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'index', 'type': 'number' },\n            { 'start': 2, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{\n                'tfName': 'dtype',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    },\n    {\n        'tfOpName': 'TensorArrayGatherV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'element_shape', 'name': 'elementShape', 'type': 'shape' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayScatterV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'indices', 'type': 'number[]' },\n            { 'start': 2, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorArrayConcatV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }, {\n                'tfName': 'element_shape_except0',\n                'name': 'elementShapeExcept0',\n                'type': 'shape',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArraySplitV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'tensor', 'type': 'tensor' },\n            { 'start': 2, 'name': 'lengths', 'type': 'number[]' },\n            { 'start': 3, 'name': 'flowIn', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TensorArraySizeV3',\n        'category': 'control',\n        'inputs': [\n            { 'start': 0, 'name': 'tensorArrayId', 'type': 'number' },\n            { 'start': 1, 'name': 'flowIn', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'TensorArrayCloseV3',\n        'category': 'control',\n        'inputs': [{ 'start': 0, 'name': 'tensorArrayId', 'type': 'number' }]\n    }\n];\n//# sourceMappingURL=control.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'AvgPool',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'MaxPool',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            },\n            { 'tfName': 'ksize', 'name': 'kernelSize', 'type': 'number[]' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Conv1D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'stride', 'name': 'stride', 'type': 'number' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NWC'\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }, {\n                'tfName': 'dilation',\n                'name': 'dilation',\n                'type': 'number',\n                'defaultValue': 1\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Conv2D',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true },\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' },\n            { 'tfName': 'useCudnnOnGpu', 'name': 'useCudnnOnGpu', 'type': 'bool' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Conv2DBackpropInput',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 2, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n            { 'start': 0, 'name': 'outputShape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'DepthwiseConv2d',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'input', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'DepthwiseConv2dNative',\n        'category': 'convolution',\n        'inputs': [\n            { 'start': 0, 'name': 'input', 'type': 'tensor' },\n            { 'start': 1, 'name': 'filter', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'strides', 'name': 'strides', 'type': 'number[]' },\n            { 'tfName': 'padding', 'name': 'pad', 'type': 'string' }, {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'defaultValue': 'NHWC'\n            },\n            { 'tfName': 'dilations', 'name': 'dilations', 'type': 'number[]' }\n        ]\n    }\n];\n//# sourceMappingURL=convolution.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Fill',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n            { 'start': 1, 'name': 'value', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'LinSpace',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'start', 'type': 'number' },\n            { 'start': 1, 'name': 'stop', 'type': 'number' },\n            { 'start': 2, 'name': 'num', 'type': 'number' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'OneHot',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'depth', 'type': 'number' },\n            { 'start': 2, 'name': 'onValue', 'type': 'number', 'defaultValue': 1 },\n            { 'start': 3, 'name': 'offValue', 'type': 'number', 'defaultValue': 0 },\n        ],\n        'attrs': [\n            {\n                'tfName': 'axis',\n                'name': 'axis',\n                'type': 'number',\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Ones',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'OnesLike',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{ 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'RandomUniform',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'minval',\n                'name': 'minval',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'maxval',\n                'name': 'maxval',\n                'type': 'number',\n                'defaultValue': 1\n            },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'seed', 'name': 'seed', 'type': 'number', 'defaultValue': 0 }, {\n                'tfName': 'seed2',\n                'name': 'seed2',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            },\n            { 'tfName': 'T', 'name': 'T', 'type': 'number', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Range',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'start', 'type': 'number' },\n            { 'start': 1, 'name': 'stop', 'type': 'number' },\n            { 'start': 2, 'name': 'step', 'type': 'number', 'defaultValue': 0 },\n        ],\n        'attrs': [{ 'tfName': 'Tidx', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'TruncatedNormal',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'means',\n                'name': 'mean',\n                'type': 'number',\n                'defaultValue': 0.0\n            },\n            {\n                'tfName': 'stddev',\n                'name': 'stdDev',\n                'type': 'number',\n                'defaultValue': 1.0\n            },\n            { 'tfName': 'seed', 'name': 'seed', 'type': 'number' }, {\n                'tfName': 'seed2',\n                'name': 'seed2',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' },\n            { 'tfName': 'T', 'name': 'T', 'type': 'number', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Zeros',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'shape', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    },\n    {\n        'tfOpName': 'ZerosLike',\n        'category': 'creation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{ 'tfName': 'T', 'name': 'dtype', 'type': 'dtype' }]\n    }\n];\n//# sourceMappingURL=creation.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'NonMaxSuppressionV2',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'NonMaxSuppressionV3',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scores', 'type': 'tensor' },\n            { 'start': 2, 'name': 'maxOutputSize', 'type': 'number' },\n            { 'start': 3, 'name': 'iouThreshold', 'type': 'number' },\n            { 'start': 4, 'name': 'scoreThreshold', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Where',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'condition', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ListDiff',\n        'category': 'dynamic',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'y', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=dynamic.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [{\n        'tfOpName': 'TopKV2',\n        'category': 'evaluation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'k', 'type': 'number' },\n        ],\n        'attrs': [{ 'tfName': 'sorted', 'name': 'sorted', 'type': 'bool' }]\n    }];\n//# sourceMappingURL=evaluation.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'PlaceholderWithDefault',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'default', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'shape', 'name': 'shape', 'type': 'shape' },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'Placeholder',\n        'category': 'graph',\n        'attrs': [\n            { 'tfName': 'shape', 'name': 'shape', 'type': 'shape' },\n            { 'tfName': 'dtype', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    { 'tfOpName': 'Const', 'category': 'graph' }, {\n        'tfOpName': 'Identity',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'IdentityN',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'x', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Snapshot',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Rank',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Size',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'Shape',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'ShapeN',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'end': 0, 'name': 'x', 'type': 'tensors' }]\n    },\n    {\n        'tfOpName': 'Print',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'data', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'message', 'name': 'message', 'type': 'string' }, {\n                'tfName': 'first_n',\n                'name': 'firstN',\n                'type': 'number',\n                'notSupported': true\n            },\n            {\n                'tfName': 'summarize',\n                'name': 'summarize',\n                'type': 'number',\n                'defaultValue': 3\n            }\n        ]\n    },\n    { 'tfOpName': 'NoOp', 'category': 'graph', 'inputs': [] }, {\n        'tfOpName': 'StopGradient',\n        'category': 'graph',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'FakeQuantWithMinMaxVars',\n        'category': 'graph',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'min', 'name': 'min', 'type': 'number' },\n            { 'tfName': 'max', 'name': 'max', 'type': 'number' }\n        ]\n    }\n];\n//# sourceMappingURL=graph.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'ResizeBilinear',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'images', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'align_corners', 'name': 'alignCorners', 'type': 'bool' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ResizeNearestNeighbor',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'images', 'type': 'tensor' },\n            { 'start': 1, 'name': 'size', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'align_corners', 'name': 'alignCorners', 'type': 'bool' },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'CropAndResize',\n        'category': 'image',\n        'inputs': [\n            { 'start': 0, 'name': 'image', 'type': 'tensor' },\n            { 'start': 1, 'name': 'boxes', 'type': 'tensor' },\n            { 'start': 2, 'name': 'boxInd', 'type': 'tensor' },\n            { 'start': 3, 'name': 'cropSize', 'type': 'number[]' },\n        ],\n        'attrs': [\n            { 'tfName': 'method', 'name': 'method', 'type': 'string' }, {\n                'tfName': 'extrapolation_value',\n                'name': 'extrapolationValue',\n                'type': 'number'\n            }\n        ]\n    }\n];\n//# sourceMappingURL=image.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Equal',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'NotEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Greater',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'GreaterEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Less',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LessEqual',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalAnd',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalNot',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'LogicalOr',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Select',\n        'category': 'logical',\n        'inputs': [\n            { 'start': 0, 'name': 'condition', 'type': 'tensor' },\n            { 'start': 1, 'name': 'a', 'type': 'tensor' },\n            { 'start': 2, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=logical.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'MatMul',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'transpose_a',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'transpose_b',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'BatchMatMul',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'a', 'type': 'tensor' },\n            { 'start': 1, 'name': 'b', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'adj_x',\n                'name': 'transposeA',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            {\n                'tfName': 'adj_y',\n                'name': 'transposeB',\n                'type': 'bool',\n                'defaultValue': false\n            },\n            { 'tfName': 'T', 'name': 'dtype', 'type': 'dtype', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'Transpose',\n        'category': 'matrices',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'perm', 'type': 'number[]' },\n        ],\n        'attrs': [{\n                'tfName': 'T',\n                'name': 'dtype',\n                'type': 'dtype',\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=matrices.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'FusedBatchNorm',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'FusedBatchNormV2',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'FusedBatchNormV3',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'scale', 'type': 'tensor' },\n            { 'start': 2, 'name': 'offset', 'type': 'tensor' },\n            { 'start': 3, 'name': 'mean', 'type': 'tensor' },\n            { 'start': 4, 'name': 'variance', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'epsilon',\n                'name': 'epsilon',\n                'type': 'number',\n                'defaultValue': 0.001\n            },\n            {\n                'tfName': 'data_format',\n                'name': 'dataFormat',\n                'type': 'string',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'LRN',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'depth_radius',\n                'name': 'radius',\n                'type': 'number',\n                'defaultValue': 5\n            },\n            { 'tfName': 'bias', 'name': 'bias', 'type': 'number', 'defaultValue': 1.0 },\n            {\n                'tfName': 'alpha',\n                'name': 'alpha',\n                'type': 'number',\n                'defaultValue': 1.0\n            },\n            {\n                'tfName': 'beta',\n                'name': 'beta',\n                'type': 'number',\n                'defaultValue': 0.5\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Softmax',\n        'category': 'normalization',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'LogSoftmax',\n        'category': 'normalization',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'SparseToDense',\n        'category': 'normalization',\n        'inputs': [\n            { 'start': 0, 'name': 'sparseIndices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'outputShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'sparseValues', 'type': 'tensor' },\n            { 'start': 3, 'name': 'defaultValue', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'defaultValue': true,\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=normalization.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Max',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Mean',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Min',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Sum',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'All',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'Any',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    },\n    {\n        'tfOpName': 'ArgMax',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'ArgMin',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Prod',\n        'category': 'reduction',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' },\n        ],\n        'attrs': [{ 'tfName': 'keep_dims', 'name': 'keepDims', 'type': 'bool' }]\n    }\n];\n//# sourceMappingURL=reduction.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'ConcatV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'end': -1, 'name': 'tensors', 'type': 'tensors' },\n            { 'start': -1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Concat',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 1, 'end': 0, 'name': 'tensors', 'type': 'tensors' },\n            { 'start': 0, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'GatherV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 2, 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ]\n    },\n    {\n        'tfOpName': 'Gather',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'axis', 'name': 'axis', 'type': 'number', 'defaultValue': 0 }, {\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Reverse',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'dims', 'type': 'bool', 'notSupported': true }\n        ]\n    },\n    {\n        'tfOpName': 'ReverseV2',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Slice',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'begin', 'type': 'number[]' },\n            { 'start': 2, 'name': 'size', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'StridedSlice',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'begin', 'type': 'number[]' },\n            { 'start': 2, 'name': 'end', 'type': 'number[]' },\n            { 'start': 3, 'name': 'strides', 'type': 'number[]' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'begin_mask',\n                'name': 'beginMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'end_mask',\n                'name': 'endMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'new_axis_mask',\n                'name': 'newAxisMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'ellipsis_mask',\n                'name': 'ellipsisMask',\n                'type': 'number',\n                'defaultValue': 0\n            },\n            {\n                'tfName': 'shrink_axis_mask',\n                'name': 'shrinkAxisMask',\n                'type': 'number',\n                'defaultValue': 0\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Pack',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'end': 0, 'name': 'tensors', 'type': 'tensors' },\n        ],\n        'attrs': [\n            { 'tfName': 'axis', 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ]\n    },\n    {\n        'tfOpName': 'Unpack',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'tensor', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'axis', 'name': 'axis', 'type': 'number', 'defaultValue': 0 }, {\n                'tfName': 'num',\n                'name': 'num',\n                'type': 'number',\n                'defaultValue': 0,\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Tile',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'reps', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Split',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'axis', 'type': 'number', 'defaultValue': 0 },\n            { 'start': 1, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'num_split',\n                'name': 'numOrSizeSplits',\n                'type': 'number',\n                'defaultValue': 1\n            }]\n    },\n    {\n        'tfOpName': 'SplitV',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'numOrSizeSplits', 'type': 'number[]' },\n            { 'start': 2, 'name': 'axis', 'type': 'number', 'defaultValue': 0 }\n        ]\n    },\n    {\n        'tfOpName': 'ScatterNd',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'indices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'values', 'type': 'tensor' },\n            { 'start': 2, 'name': 'shape', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'GatherNd',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'indices', 'type': 'tensor' }\n        ]\n    },\n    {\n        'tfOpName': 'SparseToDense',\n        'category': 'slice_join',\n        'inputs': [\n            { 'start': 0, 'name': 'sparseIndices', 'type': 'tensor' },\n            { 'start': 1, 'name': 'outputShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'sparseValues', 'type': 'tensor' },\n            { 'start': 3, 'name': 'defaultValue', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'validate_indices',\n                'name': 'validateIndices',\n                'type': 'bool',\n                'defaultValue': false,\n                'notSupported': true\n            }]\n    }\n];\n//# sourceMappingURL=slice_join.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'FFT',\n        'category': 'spectral',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'IFFT',\n        'category': 'spectral',\n        'inputs': [{ 'start': 0, 'name': 'x', 'type': 'tensor' }]\n    },\n    {\n        'tfOpName': 'RFFT',\n        'category': 'spectral',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' }, {\n                'start': 1,\n                'name': 'fft_length',\n                'type': 'number',\n                'notSupported': true\n            }\n        ]\n    },\n    {\n        'tfOpName': 'IRFFT',\n        'category': 'spectral',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' }, {\n                'start': 1,\n                'name': 'fft_length',\n                'type': 'number',\n                'notSupported': true\n            }\n        ]\n    }\n];\n//# sourceMappingURL=spectral.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexports.json = [\n    {\n        'tfOpName': 'Cast',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            {\n                'tfName': 'SrcT',\n                'name': 'sdtype',\n                'type': 'dtype',\n                'notSupported': true\n            },\n            { 'tfName': 'DstT', 'name': 'dtype', 'type': 'dtype' }\n        ]\n    },\n    {\n        'tfOpName': 'ExpandDims',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'axis', 'type': 'number' }\n        ]\n    },\n    {\n        'tfOpName': 'Pad',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'padding', 'type': 'number[]' },\n        ],\n        'attrs': [{\n                'tfName': 'constant_value',\n                'name': 'constantValue',\n                'type': 'number',\n                'defaultValue': 0\n            }]\n    },\n    {\n        'tfOpName': 'PadV2',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'padding', 'type': 'number[]' }, {\n                'start': 2,\n                'name': 'constantValue',\n                'type': 'number',\n                'defaultValue': 0\n            }\n        ]\n    },\n    {\n        'tfOpName': 'Reshape',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'shape', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'Squeeze',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [{\n                'tfName': 'axis',\n                'tfDeprecatedName': 'squeeze_dims',\n                'name': 'axis',\n                'type': 'number[]'\n            }]\n    },\n    {\n        'tfOpName': 'SpaceToBatchND',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'blockShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'paddings', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'BatchToSpaceND',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n            { 'start': 1, 'name': 'blockShape', 'type': 'number[]' },\n            { 'start': 2, 'name': 'crops', 'type': 'number[]' }\n        ]\n    },\n    {\n        'tfOpName': 'DepthToSpace',\n        'category': 'transformation',\n        'inputs': [\n            { 'start': 0, 'name': 'x', 'type': 'tensor' },\n        ],\n        'attrs': [\n            { 'tfName': 'block_size', 'name': 'blockSize', 'type': 'number' },\n            { 'tfName': 'data_format', 'name': 'dataFormat', 'type': 'string' }\n        ]\n    }\n];\n//# sourceMappingURL=transformation.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"../operations/executors/utils\");\nvar operation_executor_1 = require(\"../operations/operation_executor\");\nvar execution_context_1 = require(\"./execution_context\");\nvar model_analysis_1 = require(\"./model_analysis\");\nvar GraphExecutor = /** @class */ (function () {\n    function GraphExecutor(graph) {\n        this.graph = graph;\n        this.compiledMap = new Map();\n        this._weightMap = {};\n        this.SEPERATOR = ',';\n        this.placeholders = graph.placeholders;\n        this._outputs = graph.outputs;\n    }\n    Object.defineProperty(GraphExecutor.prototype, \"weightMap\", {\n        get: function () {\n            return this._weightMap;\n        },\n        set: function (weightMap) {\n            var weightIds = Object.keys(weightMap).map(function (key) { return weightMap[key].map(function (tensor) { return tensor.id; }); });\n            this.weightIds = [].concat.apply([], weightIds);\n            this._weightMap = weightMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"inputs\", {\n        get: function () {\n            return this.placeholders.map(function (node) {\n                return {\n                    name: node.name,\n                    shape: node.attrParams['shape'] ?\n                        node.attrParams['shape'].value :\n                        undefined,\n                    dtype: node.attrParams['dtype'] ?\n                        node.attrParams['dtype'].value :\n                        undefined\n                };\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"outputs\", {\n        get: function () {\n            return this._outputs.map(function (node) {\n                return {\n                    name: node.name,\n                    shape: node.attrParams['shape'] ?\n                        node.attrParams['shape'].value :\n                        undefined,\n                    dtype: node.attrParams['dtype'] ?\n                        node.attrParams['dtype'].value :\n                        undefined\n                };\n            });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"inputNodes\", {\n        get: function () {\n            return this.placeholders.map(function (node) { return node.name; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(GraphExecutor.prototype, \"outputNodes\", {\n        get: function () {\n            return this.outputs.map(function (node) { return node.name; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GraphExecutor.prototype.getCompilationKey = function (inputs, outputs) {\n        var sortedInputs = inputs.map(function (node) { return node.name; }).sort();\n        var sortedOutputs = outputs.map(function (node) { return node.name; }).sort();\n        return sortedInputs.join(this.SEPERATOR) + '--' +\n            sortedOutputs.join(this.SEPERATOR);\n    };\n    /**\n     * Compiles the inference graph and returns the minimal set of nodes that are\n     * required for execution, in the correct execution order.\n     */\n    GraphExecutor.prototype.compile = function (inputs, outputs) {\n        var executionInfo = model_analysis_1.getExecutionSubgraph(inputs, outputs, this.weightMap);\n        var missingInputs = executionInfo.missingInputs, dynamicNode = executionInfo.dynamicNode, syncInputs = executionInfo.syncInputs;\n        if (dynamicNode != null) {\n            throw new Error(\"This execution contains the node '\" + dynamicNode.name + \"', which has \" +\n                (\"the dynamic op '\" + dynamicNode.op + \"'. Please use \") +\n                \"model.executeAsync() instead. Alternatively, to avoid the \" +\n                (\"dynamic ops, specify the inputs [\" + syncInputs + \"]\"));\n        }\n        if (missingInputs.length > 0) {\n            var outNames = outputs.map(function (n) { return n.name; });\n            var inNames = Object.keys(inputs);\n            throw new Error(\"Cannot compute the outputs [\" + outNames + \"] from the provided inputs \" +\n                (\"[\" + inNames + \"]. Missing the following inputs: [\" + missingInputs + \"]\"));\n        }\n        return model_analysis_1.getNodesInTopologicalOrder(this.graph, this.weightMap, executionInfo);\n    };\n    /**\n     * Executes the inference for given input tensors.\n     * @param inputs Tensor map for the model inputs, keyed by the input node\n     * names.\n     * @param outputs output node name from the Tensorflow model, if no outputs\n     * are specified, the default outputs of the model would be used. You can\n     * inspect intermediate nodes of the model by adding them to the outputs\n     * array.\n     */\n    GraphExecutor.prototype.execute = function (inputs, outputs) {\n        var _this = this;\n        var names = Object.keys(inputs).sort();\n        this.checkInputs(inputs);\n        this.checkInputShapeAndType(inputs);\n        this.checkOutputs(outputs);\n        var inputNodes = names.map(function (name) { return _this.graph.nodes[name]; });\n        var outputNodes = outputs.map(function (name) { return _this.graph.nodes[utils_1.parseNodeName(name)[0]]; });\n        var compilationKey = this.getCompilationKey(inputNodes, outputNodes);\n        // Do nothing if the compiled graph cache contains the input.\n        var orderedNodes = this.compiledMap.get(compilationKey);\n        if (orderedNodes == null) {\n            orderedNodes = this.compile(inputs, outputNodes);\n            this.compiledMap.set(compilationKey, orderedNodes);\n        }\n        var tensorArrayMap = {};\n        return tfjs_core_1.tidy(function () {\n            var context = new execution_context_1.ExecutionContext(_this._weightMap, tensorArrayMap);\n            var tensorsMap = __assign({}, _this.weightMap);\n            Object.keys(inputs).forEach(function (name) {\n                tensorsMap[name] = [inputs[name]];\n            });\n            var tensorsToKeep = _this.getFrozenTensorIds(tensorsMap);\n            var intermediateTensorConsumerCount = {};\n            for (var i = 0; i < orderedNodes.length; i++) {\n                var node = orderedNodes[i];\n                if (!tensorsMap[node.name]) {\n                    var tensors = operation_executor_1.executeOp(node, tensorsMap, context);\n                    if (tensors instanceof Promise) {\n                        throw new Error(\"The execution of the op '\" + node.op + \"' returned a promise. \" +\n                            \"Please use model.executeAsync() instead.\");\n                    }\n                    tensorsMap[node.name] = tensors;\n                    _this.checkTensorForDisposal(node.name, node, tensorsMap, context, tensorsToKeep, outputs, intermediateTensorConsumerCount);\n                }\n            }\n            return outputs.map(function (name) { return utils_1.getTensor(name, tensorsMap, context); });\n        });\n    };\n    GraphExecutor.prototype.getFrozenTensorIds = function (tensorMap) {\n        var ids = [].concat.apply([], Object.keys(tensorMap)\n            .map(function (key) { return tensorMap[key]; })\n            .map(function (tensors) { return tensors.map(function (tensor) { return tensor.id; }); }));\n        return new Set(ids);\n    };\n    GraphExecutor.prototype.checkTensorForDisposal = function (nodeName, node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount) {\n        // Skip output nodes and any control flow nodes, since its dependency is\n        // tricky to track correctly.\n        if (node.category === 'control' || outputNames.indexOf(nodeName) !== -1) {\n            return;\n        }\n        tensorMap[nodeName].forEach(function (tensor) {\n            if (tensor != null) {\n                intermediateTensorConsumerCount[tensor.id] =\n                    (intermediateTensorConsumerCount[tensor.id] || 0) +\n                        node.children.length;\n            }\n        });\n        node.inputs.forEach(function (input) {\n            // Skip any control flow nodes, since its dependency is tricky to track\n            // correctly.\n            if (input.category !== 'control') {\n                var tensors = utils_1.getTensorsForCurrentContenxt(input.name, tensorMap, context);\n                if (tensors != null) {\n                    tensors.forEach(function (tensor) {\n                        if (tensor && !tensorsToKeep.has(tensor.id)) {\n                            var count = intermediateTensorConsumerCount[tensor.id];\n                            if (count === 1) {\n                                tensor.dispose();\n                                delete intermediateTensorConsumerCount[tensor.id];\n                            }\n                            else if (count != null) {\n                                // only intermediate nodes has count set, inputs and weights are\n                                // not.\n                                intermediateTensorConsumerCount[tensor.id]--;\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    };\n    /**\n     * Executes the inference for given input tensors in Async fashion.\n     * @param inputs Tensor map for the model inputs, keyed by the input node\n     * names.\n     * @param outputs output node name from the Tensorflow model, if no outputs\n     * are specified, the default outputs of the model would be used. You can\n     * inspect intermediate nodes of the model by adding them to the outputs\n     * array.\n     */\n    GraphExecutor.prototype.executeAsync = function (inputs, outputs) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tensorArrayMap, context, tensorMap, results, outputIds, inputIds;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.checkInputs(inputs);\n                        this.checkInputShapeAndType(inputs);\n                        tensorArrayMap = {};\n                        context = new execution_context_1.ExecutionContext(this._weightMap, tensorArrayMap);\n                        return [4 /*yield*/, this.executeWithControlFlow(inputs, context, outputs)];\n                    case 1:\n                        tensorMap = _a.sent();\n                        results = outputs.map(function (name) { return utils_1.getTensor(name, tensorMap, context); });\n                        outputIds = new Set(results.map(function (t) { return t.id; }));\n                        inputIds = new Set(Object.keys(inputs).map(function (name) { return inputs[name].id; }));\n                        Object.keys(tensorMap).forEach(function (key) {\n                            var tensorArray = tensorMap[key];\n                            tensorArray.forEach(function (tensor) {\n                                if (tensor && !tensor.isDisposed && !outputIds.has(tensor.id) &&\n                                    !inputIds.has(tensor.id) &&\n                                    _this.weightIds.indexOf(tensor.id) === -1) {\n                                    tensor.dispose();\n                                }\n                            });\n                        });\n                        return [2 /*return*/, results];\n                }\n            });\n        });\n    };\n    /**\n     * When there are control flow nodes in the graph, the graph execution use\n     * ExecutionContext to keep track of the frames and loop iterators.\n     * @param inputs placeholder tensors for the graph.\n     * @param context the execution context object for current execution.\n     */\n    GraphExecutor.prototype.executeWithControlFlow = function (inputs, context, outputNames) {\n        return __awaiter(this, void 0, void 0, function () {\n            var names, inputNodes, outputNodes, _a, usedNodes, missingInputs, dynamicNode, syncInputs, stack, tensorsMap, intermediateTensorConsumerCount, tensorsToKeep, added, promises, missingOutputs, alternativeMsg;\n            var _this = this;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        names = Object.keys(inputs);\n                        inputNodes = names.map(function (name) { return _this.graph.nodes[name]; });\n                        outputNodes = outputNames.map(function (name) { return _this.graph.nodes[utils_1.parseNodeName(name)[0]]; });\n                        _a = model_analysis_1.getExecutionSubgraph(inputs, outputNodes, this.weightMap), usedNodes = _a.usedNodes, missingInputs = _a.missingInputs, dynamicNode = _a.dynamicNode, syncInputs = _a.syncInputs;\n                        stack = inputNodes.concat(this.graph.weights).map(function (node) {\n                            return { node: node, contexts: context.currentContext };\n                        });\n                        tensorsMap = __assign({}, this.weightMap);\n                        Object.keys(inputs).forEach(function (name) {\n                            tensorsMap[name] = [inputs[name]];\n                        });\n                        intermediateTensorConsumerCount = {};\n                        tensorsToKeep = this.getFrozenTensorIds(tensorsMap);\n                        added = {};\n                        _b.label = 1;\n                    case 1:\n                        if (!(stack.length > 0)) return [3 /*break*/, 3];\n                        promises = this.processStack(inputNodes, stack, context, tensorsMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes);\n                        return [4 /*yield*/, Promise.all(promises)];\n                    case 2:\n                        _b.sent();\n                        return [3 /*break*/, 1];\n                    case 3:\n                        if (dynamicNode == null) {\n                            console.warn(\"This model execution did not contain any nodes with control flow \" +\n                                \"or dynamic output shapes. You can use model.execute() instead.\");\n                        }\n                        missingOutputs = outputNodes\n                            .filter(function (node) { return !model_analysis_1.isControlFlow(node) &&\n                            !utils_1.getTensor(node.name, tensorsMap, context); })\n                            .map(function (node) { return node.name; });\n                        if (missingOutputs.length > 0) {\n                            alternativeMsg = '';\n                            if (dynamicNode != null) {\n                                alternativeMsg =\n                                    \"Alternatively, to avoid the dynamic ops, use model.execute() \" +\n                                        (\"and specify the inputs [\" + syncInputs + \"]\");\n                            }\n                            throw new Error(\"Cannot compute the outputs [\" + missingOutputs + \"] from the provided \" +\n                                (\"inputs [\" + names + \"]. Consider providing the following inputs: \") +\n                                (\"[\" + missingInputs + \"]. \" + alternativeMsg));\n                        }\n                        return [2 /*return*/, tensorsMap];\n                }\n            });\n        });\n    };\n    GraphExecutor.prototype.processStack = function (inputNodes, stack, context, tensorMap, added, tensorsToKeep, outputNames, intermediateTensorConsumerCount, usedNodes) {\n        var _this = this;\n        var promises = [];\n        var _loop_1 = function () {\n            var item = stack.pop();\n            context.currentContext = item.contexts;\n            var nodeName = '';\n            // The tensor of the Enter op with isConstant set should be set\n            // in the parent scope, so it will be available as constant for the\n            // whole loop.\n            if (item.node.op === 'Enter' &&\n                utils_1.getParamValue('isConstant', item.node, tensorMap, context)) {\n                nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];\n            }\n            // only process nodes that are not provided as input nodes.\n            if (inputNodes.indexOf(item.node) === -1) {\n                var tensors = operation_executor_1.executeOp(item.node, tensorMap, context);\n                if (!nodeName) {\n                    nodeName = utils_1.getNodeNameAndIndex(item.node.name, context)[0];\n                }\n                var currentContext_1 = context.currentContext;\n                if (tensors instanceof Promise) {\n                    promises.push(tensors.then(function (t) {\n                        tensorMap[nodeName] = t;\n                        context.currentContext = currentContext_1;\n                        _this.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);\n                        _this.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n                        return t;\n                    }));\n                }\n                else {\n                    tensorMap[nodeName] = tensors;\n                    this_1.checkTensorForDisposal(nodeName, item.node, tensorMap, context, tensorsToKeep, outputNames, intermediateTensorConsumerCount);\n                    this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n                }\n            }\n            else {\n                this_1.processChildNodes(item.node, stack, context, tensorMap, added, usedNodes);\n            }\n        };\n        var this_1 = this;\n        while (stack.length > 0) {\n            _loop_1();\n        }\n        return promises;\n    };\n    GraphExecutor.prototype.processChildNodes = function (node, stack, context, tensorMap, added, usedNodes) {\n        node.children.forEach(function (childNode) {\n            var nodeName = utils_1.getNodeNameAndIndex(childNode.name, context)[0];\n            if (added[nodeName] || !usedNodes.has(childNode.name)) {\n                return;\n            }\n            // Merge op can be pushed if any of its inputs has value.\n            if (childNode.op === 'Merge') {\n                if (childNode.inputNames.some(function (name) {\n                    return !!utils_1.getTensor(name, tensorMap, context);\n                })) {\n                    added[nodeName] = true;\n                    stack.push({ contexts: context.currentContext, node: childNode });\n                }\n            }\n            else // Otherwise all inputs must to have value.\n             if (childNode.inputNames.every(function (name) {\n                return !!utils_1.getTensor(name, tensorMap, context);\n            })) {\n                added[nodeName] = true;\n                stack.push({ contexts: context.currentContext, node: childNode });\n            }\n        });\n    };\n    /**\n     * Releases the memory used by the weight tensors.\n     */\n    GraphExecutor.prototype.dispose = function () {\n        var _this = this;\n        Object.keys(this.weightMap)\n            .forEach(function (key) { return _this.weightMap[key].forEach(function (tensor) { return tensor.dispose(); }); });\n    };\n    GraphExecutor.prototype.checkInputShapeAndType = function (inputs) {\n        var _this = this;\n        Object.keys(inputs).forEach(function (name) {\n            var input = inputs[name];\n            var node = _this.graph.nodes[name];\n            if (node.attrParams['shape'] && node.attrParams['shape'].value) {\n                var shape_1 = node.attrParams['shape'].value;\n                var match = shape_1.length === input.shape.length &&\n                    input.shape.every(function (dim, index) { return shape_1[index] === -1 || shape_1[index] === dim; });\n                tfjs_core_1.util.assert(match, function () { return \"The shape of dict['\" + node.name + \"'] provided in \" +\n                    (\"model.execute(dict) must be [\" + shape_1 + \"], but was \") +\n                    (\"[\" + input.shape + \"]\"); });\n            }\n            if (node.attrParams['dtype'] && node.attrParams['dtype'].value) {\n                tfjs_core_1.util.assert(input.dtype === node.attrParams['dtype'].value, function () { return \"The dtype of dict['\" + node.name + \"'] provided in \" +\n                    \"model.execute(dict) must be \" +\n                    (node.attrParams['dtype'].value + \", but was \" + input.dtype); });\n            }\n        });\n    };\n    GraphExecutor.prototype.checkInputs = function (inputs) {\n        var _this = this;\n        var notInGraph = Object.keys(inputs).filter(function (name) { return !_this.graph.nodes[name]; });\n        if (notInGraph.length > 0) {\n            throw new Error(\"The dict provided in model.execute(dict) has \" +\n                (\"keys: [\" + notInGraph + \"] that are not part of graph\"));\n        }\n    };\n    GraphExecutor.prototype.checkOutputs = function (outputs) {\n        var _this = this;\n        outputs.forEach(function (name) {\n            var normalizedName = utils_1.parseNodeName(name)[0];\n            if (!_this.graph.nodes[normalizedName]) {\n                throw new Error(\"The output '\" + name + \"' is not found in the graph\");\n            }\n        });\n    };\n    return GraphExecutor;\n}());\nexports.GraphExecutor = GraphExecutor;\n//# sourceMappingURL=graph_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar node_value_impl_1 = require(\"./custom_op/node_value_impl\");\nvar register_1 = require(\"./custom_op/register\");\nvar arithmetic = require(\"./executors/arithmetic_executor\");\nvar basicMath = require(\"./executors/basic_math_executor\");\nvar control = require(\"./executors/control_executor\");\nvar convolution = require(\"./executors/convolution_executor\");\nvar creation = require(\"./executors/creation_executor\");\nvar dynamic = require(\"./executors/dynamic_executor\");\nvar evaluation = require(\"./executors/evaluation_executor\");\nvar graph = require(\"./executors/graph_executor\");\nvar image = require(\"./executors/image_executor\");\nvar logical = require(\"./executors/logical_executor\");\nvar matrices = require(\"./executors/matrices_executor\");\nvar normalization = require(\"./executors/normalization_executor\");\nvar reduction = require(\"./executors/reduction_executor\");\nvar sliceJoin = require(\"./executors/slice_join_executor\");\nvar spectral = require(\"./executors/spectral_executor\");\nvar transformation = require(\"./executors/transformation_executor\");\n/**\n * Executes the op defined by the node object.\n * @param node\n * @param tensorMap contains tensors for executed nodes and weights\n */\nfunction executeOp(node, tensorMap, context) {\n    var value = (function (node, tensorMap, context) {\n        switch (node.category) {\n            case 'arithmetic':\n                return arithmetic.executeOp(node, tensorMap, context);\n            case 'basic_math':\n                return basicMath.executeOp(node, tensorMap, context);\n            case 'control':\n                return control.executeOp(node, tensorMap, context);\n            case 'convolution':\n                return convolution.executeOp(node, tensorMap, context);\n            case 'creation':\n                return creation.executeOp(node, tensorMap, context);\n            case 'dynamic':\n                return dynamic.executeOp(node, tensorMap, context);\n            case 'evaluation':\n                return evaluation.executeOp(node, tensorMap, context);\n            case 'image':\n                return image.executeOp(node, tensorMap, context);\n            case 'graph':\n                return graph.executeOp(node, tensorMap, context);\n            case 'logical':\n                return logical.executeOp(node, tensorMap, context);\n            case 'matrices':\n                return matrices.executeOp(node, tensorMap, context);\n            case 'normalization':\n                return normalization.executeOp(node, tensorMap, context);\n            case 'reduction':\n                return reduction.executeOp(node, tensorMap, context);\n            case 'slice_join':\n                return sliceJoin.executeOp(node, tensorMap, context);\n            case 'spectral':\n                return spectral.executeOp(node, tensorMap, context);\n            case 'transformation':\n                return transformation.executeOp(node, tensorMap, context);\n            case 'custom':\n                var opMapper = register_1.getRegisteredOp(node.op);\n                if (opMapper && opMapper.customExecutor) {\n                    return opMapper.customExecutor(new node_value_impl_1.NodeValueImpl(node, tensorMap, context));\n                }\n                else {\n                    throw TypeError(\"Custom op \" + node.op + \" is not registered.\");\n                }\n            default:\n                throw TypeError(\"Unknown op '\" + node.op + \"'. File an issue at \" +\n                    \"https://github.com/tensorflow/tfjs/issues so we can add it\" +\n                    \", or register a custom execution with tf.registerOp()\");\n        }\n    })(node, tensorMap, context);\n    if (value instanceof Promise) {\n        return value.then(function (data) { return [].concat(data); });\n    }\n    return [].concat(value);\n}\nexports.executeOp = executeOp;\n//# sourceMappingURL=operation_executor.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"../executors/utils\");\nvar operation_mapper_1 = require(\"../operation_mapper\");\n/**\n * Helper class for lookup inputs and params for nodes in the model graph.\n */\nvar NodeValueImpl = /** @class */ (function () {\n    function NodeValueImpl(node, tensorMap, context) {\n        var _this = this;\n        this.node = node;\n        this.tensorMap = tensorMap;\n        this.context = context;\n        this.inputs = [];\n        this.attrs = {};\n        this.inputs = node.inputNames.map(function (name) { return _this.getInput(name); });\n        if (node.rawAttrs != null) {\n            this.attrs = Object.keys(node.rawAttrs)\n                .reduce(function (attrs, key) {\n                attrs[key] = _this.getAttr(key);\n                return attrs;\n            }, {});\n        }\n    }\n    /**\n     * Return the value of the attribute or input param.\n     * @param name String: name of attribute or input param.\n     */\n    NodeValueImpl.prototype.getInput = function (name) {\n        return utils_1.getTensor(name, this.tensorMap, this.context);\n    };\n    /**\n     * Return the value of the attribute or input param.\n     * @param name String: name of attribute or input param.\n     */\n    NodeValueImpl.prototype.getAttr = function (name, defaultValue) {\n        var value = this.node.rawAttrs[name];\n        if (value.tensor != null) {\n            return utils_1.getTensor(name, this.tensorMap, this.context);\n        }\n        if (value.i != null || value.f != null) {\n            return operation_mapper_1.getNumberParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.s != null) {\n            return operation_mapper_1.getStringParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.b != null) {\n            return operation_mapper_1.getBoolParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.shape != null) {\n            return operation_mapper_1.getTensorShapeParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.type != null) {\n            return operation_mapper_1.getDtypeParam(this.node.rawAttrs, name, defaultValue);\n        }\n        if (value.list != null) {\n            if (value.list.i != null || value.list.f != null) {\n                return operation_mapper_1.getNumericArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.s != null) {\n                return operation_mapper_1.getStringArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.shape != null) {\n                return operation_mapper_1.getTensorShapeArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.b != null) {\n                return operation_mapper_1.getBoolArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n            if (value.list.type != null) {\n                return operation_mapper_1.getDtypeArrayParam(this.node.rawAttrs, name, defaultValue);\n            }\n        }\n        return defaultValue;\n    };\n    return NodeValueImpl;\n}());\nexports.NodeValueImpl = NodeValueImpl;\n//# sourceMappingURL=node_value_impl.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'BiasAdd':\n        case 'Add': {\n            return [tfc.add(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'AddN': {\n            return [tfc.addN(utils_1.getParamValue('tensors', node, tensorMap, context))];\n        }\n        case 'FloorMod':\n        case 'Mod':\n            return [tfc.mod(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        case 'Mul':\n            return [tfc.mul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        case 'RealDiv':\n        case 'Div': {\n            return [tfc.div(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'FloorDiv': {\n            return [tfc.floorDiv(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Sub': {\n            return [tfc.sub(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Minimum': {\n            return [tfc.minimum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Maximum': {\n            return [tfc.maximum(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Pow': {\n            return [tfc.pow(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'SquaredDifference': {\n            return [tfc.squaredDifference(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'arithmetic';\n//# sourceMappingURL=arithmetic_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Abs':\n        case 'ComplexAbs':\n            return [tfc.abs(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Acos':\n            return [tfc.acos(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Acosh':\n            return [tfc.acosh(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Asin':\n            return [tfc.asin(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Asinh':\n            return [tfc.asinh(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Atan':\n            return [tfc.atan(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Atan2':\n            return [tfc.atan2(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('y', node, tensorMap, context))];\n        case 'Atanh':\n            return [tfc.atanh(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Ceil':\n            return [tfc.ceil(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Complex':\n            return [tfc.complex(utils_1.getParamValue('real', node, tensorMap, context), utils_1.getParamValue('imag', node, tensorMap, context))];\n        case 'Cos':\n            return [tfc.cos(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Cosh':\n            return [tfc.cosh(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Elu':\n            return [tfc.elu(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Erf':\n            return [tfc.erf(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Exp':\n            return [tfc.exp(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Expm1': {\n            return [tfc.expm1(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Floor':\n            return [tfc.floor(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Log':\n            return [tfc.log(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Log1p': {\n            return [tfc.log1p(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Neg':\n            return [tfc.neg(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Reciprocal': {\n            return [tfc.reciprocal(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Relu':\n            return [tfc.relu(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Round': {\n            return [tfc.round(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Selu':\n            return [tfc.selu(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Sigmoid':\n            return [tfc.sigmoid(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Sin':\n            return [tfc.sin(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Sign': {\n            return [tfc.sign(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Sinh': {\n            return [tfc.sinh(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Softplus': {\n            return [tfc.softplus(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Sqrt': {\n            return [tfc.sqrt(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Square': {\n            return [tfc.square(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Tanh': {\n            return [tfc.tanh(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'Tan':\n            return [tfc.tan(utils_1.getParamValue('x', node, tensorMap, context))];\n        case 'Relu6':\n        case 'ClipByValue':\n            return [tfc.clipByValue(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('clipValueMin', node, tensorMap, context), utils_1.getParamValue('clipValueMax', node, tensorMap, context))];\n        case 'Rsqrt':\n            return [tfc.rsqrt(utils_1.getTensor(node.inputNames[0], tensorMap, context))];\n        case 'Prod':\n            return [tfc.prod(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('axes', node, tensorMap, context))];\n        case 'LeakyRelu':\n            return [tfc.leakyRelu(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context))];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'basic_math';\n//# sourceMappingURL=basic_math_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\nvar tensor_array_1 = require(\"../../executor/tensor_array\");\nvar utils_1 = require(\"./utils\");\nfunction executeOp(node, tensorMap, context) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, pred, data_1, inputName, frameId, data, tensor, input, size, dtype, elementShape, dynamicSize, clearAfterRead, identicalElementShapes, name_1, tensorArray, id, index, writeTensor, writeTensorArray, readId, readIndex, readTensorArray, gatherId, gatherIndices, gatherDtype, gatherTensorArray, scatterId, scatterIndices, scatterTensor, scatterTensorArray, concatId, concatTensorArray, concatDtype, splitId, splitTensor, lengths, splitTensorArray, sizeId, sizeTensorArray, closeId, closeTensorArray;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = node.op;\n                    switch (_a) {\n                        case 'LoopCond': return [3 /*break*/, 1];\n                        case 'Switch': return [3 /*break*/, 2];\n                        case 'Merge': return [3 /*break*/, 4];\n                        case 'Enter': return [3 /*break*/, 5];\n                        case 'Exit': return [3 /*break*/, 6];\n                        case 'NextIteration': return [3 /*break*/, 7];\n                        case 'TensorArrayV3': return [3 /*break*/, 8];\n                        case 'TensorArrayWriteV3': return [3 /*break*/, 9];\n                        case 'TensorArrayReadV3': return [3 /*break*/, 10];\n                        case 'TensorArrayGatherV3': return [3 /*break*/, 11];\n                        case 'TensorArrayScatterV3': return [3 /*break*/, 12];\n                        case 'TensorArrayConcatV3': return [3 /*break*/, 13];\n                        case 'TensorArraySplitV3': return [3 /*break*/, 14];\n                        case 'TensorArraySizeV3': return [3 /*break*/, 15];\n                        case 'TensorArrayCloseV3': return [3 /*break*/, 16];\n                    }\n                    return [3 /*break*/, 17];\n                case 1: return [2 /*return*/, [\n                        utils_1.getParamValue('pred', node, tensorMap, context).clone()\n                    ]];\n                case 2:\n                    pred = utils_1.getParamValue('pred', node, tensorMap, context);\n                    data_1 = utils_1.getParamValue('data', node, tensorMap, context);\n                    return [4 /*yield*/, pred.data()];\n                case 3: \n                // Outputs nodes :0 => false, :1 => true\n                return [2 /*return*/, (_b.sent())[0] ? [undefined, data_1.clone()] :\n                        [data_1.clone(), undefined]];\n                case 4:\n                    inputName = node.inputNames.find(function (name) { return utils_1.getTensor(name, tensorMap, context) !== undefined; });\n                    return [2 /*return*/, inputName ? [utils_1.getTensor(inputName, tensorMap, context).clone()] :\n                            undefined];\n                case 5:\n                    frameId = utils_1.getParamValue('frameName', node, tensorMap, context);\n                    data = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    context.enterFrame(frameId);\n                    return [2 /*return*/, [data.clone()]];\n                case 6:\n                    tensor = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    context.exitFrame();\n                    return [2 /*return*/, [tensor.clone()]];\n                case 7:\n                    input = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    context.nextIteration();\n                    return [2 /*return*/, [input.clone()]];\n                case 8:\n                    size = utils_1.getParamValue('size', node, tensorMap, context);\n                    dtype = utils_1.getParamValue('dtype', node, tensorMap, context);\n                    elementShape = utils_1.getParamValue('elementShape', node, tensorMap, context);\n                    dynamicSize = utils_1.getParamValue('dynamicSize', node, tensorMap, context);\n                    clearAfterRead = utils_1.getParamValue('clearAfterRead', node, tensorMap, context);\n                    identicalElementShapes = utils_1.getParamValue('identicalElementShapes', node, tensorMap, context);\n                    name_1 = utils_1.getParamValue('name', node, tensorMap, context);\n                    tensorArray = new tensor_array_1.TensorArray(name_1, dtype, size, elementShape, identicalElementShapes, dynamicSize, clearAfterRead);\n                    context.addTensorArray(tensorArray);\n                    return [2 /*return*/, [tfjs_core_1.scalar(tensorArray.id), tfjs_core_1.scalar(1.0)]];\n                case 9:\n                    id = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    index = utils_1.getParamValue('index', node, tensorMap, context);\n                    writeTensor = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    writeTensorArray = context.getTensorArray(id);\n                    writeTensorArray.write(index, writeTensor);\n                    return [2 /*return*/, [tfjs_core_1.scalar(1.0)]];\n                case 10:\n                    readId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    readIndex = utils_1.getParamValue('index', node, tensorMap, context);\n                    readTensorArray = context.getTensorArray(readId);\n                    return [2 /*return*/, [readTensorArray.read(readIndex)]];\n                case 11:\n                    gatherId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    gatherIndices = utils_1.getParamValue('indices', node, tensorMap, context);\n                    gatherDtype = utils_1.getParamValue('dtype', node, tensorMap, context);\n                    gatherTensorArray = context.getTensorArray(gatherId);\n                    return [2 /*return*/, [gatherTensorArray.gather(gatherIndices, gatherDtype)]];\n                case 12:\n                    scatterId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    scatterIndices = utils_1.getParamValue('indices', node, tensorMap, context);\n                    scatterTensor = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    scatterTensorArray = context.getTensorArray(scatterId);\n                    scatterTensorArray.scatter(scatterIndices, scatterTensor);\n                    return [2 /*return*/, [tfjs_core_1.scalar(1.0)]];\n                case 13:\n                    concatId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    concatTensorArray = context.getTensorArray(concatId);\n                    concatDtype = utils_1.getParamValue('dtype', node, tensorMap, context);\n                    return [2 /*return*/, [concatTensorArray.concat(concatDtype)]];\n                case 14:\n                    splitId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    splitTensor = utils_1.getParamValue('tensor', node, tensorMap, context);\n                    lengths = utils_1.getParamValue('lengths', node, tensorMap, context);\n                    splitTensorArray = context.getTensorArray(splitId);\n                    splitTensorArray.split(lengths, splitTensor);\n                    return [2 /*return*/, [tfjs_core_1.scalar(1.0)]];\n                case 15:\n                    sizeId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    sizeTensorArray = context.getTensorArray(sizeId);\n                    return [2 /*return*/, [tfjs_core_1.scalar(sizeTensorArray.size(), 'int32')]];\n                case 16:\n                    closeId = utils_1.getParamValue('tensorArrayId', node, tensorMap, context);\n                    closeTensorArray = context.getTensorArray(closeId);\n                    closeTensorArray.clearAndClose();\n                    return [2 /*return*/, []];\n                case 17: throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n            }\n        });\n    });\n}\nexports.executeOp = executeOp;\nexports.CATEGORY = 'control';\n//# sourceMappingURL=control_executor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line:max-line-length\nvar tfjs_core_1 = require(\"@tensorflow/tfjs-core\");\n/**\n * The TensorArray object keeps an array of Tensors.  It\n * allows reading from the array and writing to the array.\n */\nvar TensorArray = /** @class */ (function () {\n    function TensorArray(name, dtype, maxSize, elementShape, identicalElementShapes, dynamicSize, clearAfterRead) {\n        this.name = name;\n        this.dtype = dtype;\n        this.maxSize = maxSize;\n        this.elementShape = elementShape;\n        this.identicalElementShapes = identicalElementShapes;\n        this.dynamicSize = dynamicSize;\n        this.clearAfterRead = clearAfterRead;\n        this.tensors = [];\n        this.closed_ = false;\n        this.id = TensorArray.nextId++;\n    }\n    Object.defineProperty(TensorArray.prototype, \"closed\", {\n        get: function () {\n            return this.closed_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Close the current TensorArray.\n     */\n    TensorArray.prototype.clearAndClose = function () {\n        this.tensors.forEach(function (tensor) { return tensor.tensor.dispose(); });\n        this.tensors = [];\n        this.closed_ = true;\n    };\n    TensorArray.prototype.size = function () {\n        return this.tensors.length;\n    };\n    /**\n     * Read the value at location index in the TensorArray.\n     * @param index Number the index to read from.\n     */\n    TensorArray.prototype.read = function (index) {\n        if (this.closed_) {\n            throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        }\n        if (index < 0 || index >= this.tensors.length) {\n            throw new Error(\"Tried to read from index \" + index + \", but array size is: \" + this.tensors.length);\n        }\n        var tensorWithState = this.tensors[index];\n        if (tensorWithState.cleared) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not read index \" + index + \" twice because it was cleared after a previous read \" +\n                \"(perhaps try setting clear_after_read = false?).\");\n        }\n        if (this.clearAfterRead) {\n            tensorWithState.cleared = true;\n        }\n        tensorWithState.read = true;\n        return tensorWithState.tensor;\n    };\n    /**\n     * Helper method to read multiple tensors from the specified indices.\n     */\n    TensorArray.prototype.readMany = function (indices) {\n        var _this = this;\n        return indices.map(function (index) { return _this.read(index); });\n    };\n    /**\n     * Write value into the index of the TensorArray.\n     * @param index number the index to write to.\n     * @param tensor\n     */\n    TensorArray.prototype.write = function (index, tensor) {\n        if (this.closed_) {\n            throw new Error(\"TensorArray \" + this.name + \" has already been closed.\");\n        }\n        if (index < 0 || !this.dynamicSize && index >= this.maxSize) {\n            throw new Error(\"Tried to write to index \" + index + \", but array is not resizeable and size is: \" + this.maxSize);\n        }\n        var t = this.tensors[index] || {};\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \",\\n          because the value dtype is \" + tensor.dtype + \", but TensorArray dtype is \" + this.dtype + \".\");\n        }\n        // Set the shape for the first time write to unknow shape tensor array\n        if (this.size() === 0 &&\n            (this.elementShape == null || this.elementShape.length === 0)) {\n            this.elementShape = tensor.shape;\n        }\n        this.assertShapesMatchAllowUndefinedSize(this.elementShape, tensor.shape, \"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \".\");\n        if (t && t.read) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \", because it has already been read.\");\n        }\n        if (t && t.written) {\n            throw new Error(\"TensorArray \" + this.name + \": Could not write to TensorArray index \" + index + \", because it has already been written.\");\n        }\n        t.tensor = tensor;\n        t.written = true;\n        this.tensors[index] = t;\n    };\n    /**\n     * Helper method to write multiple tensors to the specified indices.\n     */\n    TensorArray.prototype.writeMany = function (indices, tensors) {\n        var _this = this;\n        if (indices.length !== tensors.length) {\n            throw new Error(\"TensorArray \" + this.name + \": could not write multiple tensors,\" +\n                (\"because the index size: \" + indices.length + \" is not the same as tensors size: \" + tensors.length + \".\"));\n        }\n        indices.forEach(function (i, index) { return _this.write(i, tensors[index]); });\n    };\n    /**\n     * Return selected values in the TensorArray as a packed Tensor. All of\n     * selected values must have been written and their shapes must all match.\n     * @param [indices] number[] Optional. Taking values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size(). If not specified returns\n     *    all tensors in the original order.\n     * @param [dtype]\n     */\n    TensorArray.prototype.gather = function (indices, dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but gather requested dtype \" + dtype);\n        }\n        if (!indices) {\n            indices = [];\n            for (var i = 0; i < this.size(); i++) {\n                indices.push(i);\n            }\n        }\n        if (indices.length === 0) {\n            return tfjs_core_1.tensor([], [0].concat(this.elementShape));\n        }\n        // Read all the PersistentTensors into a vector to keep track of\n        // their memory.\n        var tensors = this.readMany(indices);\n        this.assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, 'TensorArray shape mismatch: ');\n        return tfjs_core_1.stack(tensors, 0);\n    };\n    /**\n     * Return the values in the TensorArray as a concatenated Tensor.\n     */\n    TensorArray.prototype.concat = function (dtype) {\n        if (!!dtype && dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but concat requested dtype \" + dtype);\n        }\n        if (this.size() === 0) {\n            return tfjs_core_1.tensor([], [0].concat(this.elementShape));\n        }\n        var indices = [];\n        for (var i = 0; i < this.size(); i++) {\n            indices.push(i);\n        }\n        // Collect all the tensors from the tensors array.\n        var tensors = this.readMany(indices);\n        this.assertShapesMatchAllowUndefinedSize(this.elementShape, tensors[0].shape, \"TensorArray shape mismatch: tensor array shape (\" + this.elementShape + \") vs first tensor shape (\" + tensors[0].shape + \")\");\n        return tfjs_core_1.concat(tensors, 0);\n    };\n    /**\n     * Scatter the values of a Tensor in specific indices of a TensorArray.\n     * @param indices nummber[] values in [0, max_value). If the\n     *    TensorArray is not dynamic, max_value=size().\n     * @param tensor Tensor input tensor.\n     */\n    TensorArray.prototype.scatter = function (indices, tensor) {\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + tensor.dtype);\n        }\n        if (indices.length !== tensor.shape[0]) {\n            throw new Error(\"Expected len(indices) == tensor.shape[0], but saw: \" + indices.length + \" vs. \" + tensor.shape[0]);\n        }\n        var maxIndex = Math.max.apply(Math, indices);\n        if (!this.dynamicSize && maxIndex >= this.maxSize) {\n            throw new Error(\"Max index must be < array size (\" + maxIndex + \"  vs. \" + this.maxSize + \")\");\n        }\n        this.writeMany(indices, tfjs_core_1.unstack(tensor, 0));\n    };\n    /**\n     * Split the values of a Tensor into the TensorArray.\n     * @param length number[] with the lengths to use when splitting value along\n     *    its first dimension.\n     * @param tensor Tensor, the tensor to split.\n     */\n    TensorArray.prototype.split = function (length, tensor) {\n        var _this = this;\n        if (tensor.dtype !== this.dtype) {\n            throw new Error(\"TensorArray dtype is \" + this.dtype + \" but tensor has dtype \" + tensor.dtype);\n        }\n        var totalLength = 0;\n        var cumulativeLengths = length.map(function (len) {\n            totalLength += len;\n            return totalLength;\n        });\n        if (totalLength !== tensor.shape[0]) {\n            throw new Error(\"Expected sum of lengths to be equal to\\n          tensor.shape[0], but sum of lengths is\\n        \" + totalLength + \", and tensor's shape is: \" + tensor.shape);\n        }\n        if (!this.dynamicSize && length.length !== this.maxSize) {\n            throw new Error(\"TensorArray's size is not equal to the size of lengths (\" + this.maxSize + \" vs. \" + length.length + \"), \" +\n                'and the TensorArray is not marked as dynamically resizeable');\n        }\n        var elementPerRow = totalLength === 0 ? 0 : tensor.size / totalLength;\n        var tensors = [];\n        tfjs_core_1.tidy(function () {\n            tensor = tensor.reshape([1, totalLength, elementPerRow]);\n            for (var i = 0; i < length.length; ++i) {\n                var previousLength = (i === 0) ? 0 : cumulativeLengths[i - 1];\n                var indices_1 = [0, previousLength, 0];\n                var sizes = [1, length[i], elementPerRow];\n                tensors[i] = tfjs_core_1.slice(tensor, indices_1, sizes).reshape(_this.elementShape);\n            }\n            return tensors;\n        });\n        var indices = [];\n        for (var i = 0; i < length.length; i++) {\n            indices[i] = i;\n        }\n        this.writeMany(indices, tensors);\n    };\n    /**\n     * This differs from util.assertShapesMatch in that it allows values of\n     * negative one, an undefined size of a dimensinon, in a shape to match\n     * anything.\n     */\n    TensorArray.prototype.assertShapesMatchAllowUndefinedSize = function (shapeA, shapeB, errorMessagePrefix) {\n        if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }\n        tfjs_core_1.util.assert(this.shapesEqualAllowUndefinedSize(shapeA, shapeB), function () {\n            return errorMessagePrefix + (\" Shapes \" + shapeA + \" and \" + shapeB + \" must match\");\n        });\n    };\n    TensorArray.prototype.shapesEqualAllowUndefinedSize = function (n1, n2) {\n        if (n1.length !== n2.length) {\n            return false;\n        }\n        for (var i = 0; i < n1.length; i++) {\n            if (n1[i] !== -1 && n2[i] !== -1 && n1[i] !== n2[i]) {\n                return false;\n            }\n        }\n        return true;\n    };\n    TensorArray.nextId = 0;\n    return TensorArray;\n}());\nexports.TensorArray = TensorArray;\n//# sourceMappingURL=tensor_array.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Conv1D': {\n            var stride = utils_1.getParamValue('stride', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            var dilation = utils_1.getParamValue('dilation', node, tensorMap, context);\n            return [tfc.conv1d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), stride, pad, dataFormat, dilation)];\n        }\n        case 'Conv2D': {\n            var stride = utils_1.getParamValue('strides', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);\n            return [tfc.conv2d(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n        }\n        case 'Conv2DBackpropInput':\n        case 'Conv2dTranspose': {\n            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);\n            var stride = utils_1.getParamValue('strides', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            return [tfc.conv2dTranspose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), shape, [stride[1], stride[2]], pad)];\n        }\n        case 'DepthwiseConv2dNative':\n        case 'DepthwiseConv2d': {\n            var stride = utils_1.getParamValue('strides', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            var dilations = utils_1.getParamValue('dilations', node, tensorMap, context);\n            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context)\n                .toUpperCase();\n            return [tfc.depthwiseConv2d(utils_1.getParamValue('input', node, tensorMap, context), utils_1.getParamValue('filter', node, tensorMap, context), [stride[1], stride[2]], pad, dataFormat, [dilations[1], dilations[2]])];\n        }\n        case 'AvgPool': {\n            var stride = utils_1.getParamValue('strides', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);\n            return [tfc.avgPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n        }\n        case 'MaxPool': {\n            var stride = utils_1.getParamValue('strides', node, tensorMap, context);\n            var pad = utils_1.getParamValue('pad', node, tensorMap, context);\n            var kernelSize = utils_1.getParamValue('kernelSize', node, tensorMap, context);\n            return [tfc.maxPool(utils_1.getParamValue('x', node, tensorMap, context), [kernelSize[1], kernelSize[2]], [stride[1], stride[2]], pad)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'convolution';\n//# sourceMappingURL=convolution_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Fill': {\n            var shape = utils_1.getParamValue('shape', node, tensorMap, context);\n            var dtype = utils_1.getParamValue('dtype', node, tensorMap, context);\n            var value = utils_1.getParamValue('value', node, tensorMap, context);\n            return [tfc.fill(shape, value, dtype)];\n        }\n        case 'LinSpace': {\n            var start = utils_1.getParamValue('start', node, tensorMap, context);\n            var stop_1 = utils_1.getParamValue('stop', node, tensorMap, context);\n            var num = utils_1.getParamValue('num', node, tensorMap, context);\n            return [tfc.linspace(start, stop_1, num)];\n        }\n        case 'OneHot': {\n            var indices = utils_1.getParamValue('indices', node, tensorMap, context);\n            var depth = utils_1.getParamValue('depth', node, tensorMap, context);\n            var onValue = utils_1.getParamValue('onValue', node, tensorMap, context);\n            var offValue = utils_1.getParamValue('offValue', node, tensorMap, context);\n            return [tfc.oneHot(indices, depth, onValue, offValue)];\n        }\n        case 'Ones': {\n            return [tfc.ones(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'OnesLike': {\n            return [tfc.onesLike(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'RandomUniform': {\n            return [tfc.randomUniform(\n                // tslint:disable-next-line:no-any\n                utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('minval', node, tensorMap, context), utils_1.getParamValue('maxval', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'Range': {\n            var start = utils_1.getParamValue('start', node, tensorMap, context);\n            var stop_2 = utils_1.getParamValue('stop', node, tensorMap, context);\n            var step = utils_1.getParamValue('step', node, tensorMap, context);\n            return [tfc.range(start, stop_2, step, utils_1.getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'TruncatedNormal': {\n            var shape = utils_1.getParamValue('shape', node, tensorMap, context);\n            var mean = utils_1.getParamValue('mean', node, tensorMap, context);\n            var stdDev = utils_1.getParamValue('stdDev', node, tensorMap, context);\n            var seed = utils_1.getParamValue('seed', node, tensorMap, context);\n            return [tfc.truncatedNormal(shape, mean, stdDev, utils_1.getParamValue('dtype', node, tensorMap, context), seed)];\n        }\n        case 'Zeros': {\n            return [tfc.zeros(utils_1.getParamValue('shape', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'ZerosLike': {\n            return [tfc.zerosLike(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'creation';\n//# sourceMappingURL=creation_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nfunction executeOp(node, tensorMap, context) {\n    return __awaiter(this, void 0, void 0, function () {\n        var _a, boxes, scores, maxOutputSize, iouThreshold, scoreThreshold;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    _a = node.op;\n                    switch (_a) {\n                        case 'NonMaxSuppressionV3': return [3 /*break*/, 1];\n                        case 'NonMaxSuppressionV2': return [3 /*break*/, 1];\n                        case 'Where': return [3 /*break*/, 3];\n                        case 'ListDiff': return [3 /*break*/, 5];\n                    }\n                    return [3 /*break*/, 7];\n                case 1:\n                    boxes = utils_1.getParamValue('boxes', node, tensorMap, context);\n                    scores = utils_1.getParamValue('scores', node, tensorMap, context);\n                    maxOutputSize = utils_1.getParamValue('maxOutputSize', node, tensorMap, context);\n                    iouThreshold = utils_1.getParamValue('iouThreshold', node, tensorMap, context);\n                    scoreThreshold = utils_1.getParamValue('scoreThreshold', node, tensorMap, context);\n                    return [4 /*yield*/, tfc.image.nonMaxSuppressionAsync(boxes, scores, maxOutputSize, iouThreshold, scoreThreshold)];\n                case 2: return [2 /*return*/, [_b.sent()]];\n                case 3: return [4 /*yield*/, tfc.whereAsync(utils_1.getParamValue('condition', node, tensorMap, context))];\n                case 4: return [2 /*return*/, [_b.sent()]];\n                case 5: return [4 /*yield*/, tfc.setdiff1dAsync(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('y', node, tensorMap, context))];\n                case 6: return [2 /*return*/, _b.sent()];\n                case 7: throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n            }\n        });\n    });\n}\nexports.executeOp = executeOp;\nexports.CATEGORY = 'dynamic';\n//# sourceMappingURL=dynamic_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'TopKV2': {\n            var x = utils_1.getParamValue('x', node, tensorMap, context);\n            var k = utils_1.getParamValue('k', node, tensorMap, context);\n            var sorted = utils_1.getParamValue('sorted', node, tensorMap, context);\n            var result = tfc.topk(x, k, sorted);\n            return [result.values, result.indices];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'evaluation';\n//# sourceMappingURL=evaluation_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Const': {\n            return tensorMap[node.name];\n        }\n        case 'PlaceholderWithDefault':\n            var def = utils_1.getParamValue('default', node, tensorMap, context);\n            return [utils_1.getTensor(node.name, tensorMap, context) || def];\n        case 'Placeholder':\n            return [utils_1.getTensor(node.name, tensorMap, context)];\n        case 'Identity':\n        case 'StopGradient':\n        case 'FakeQuantWithMinMaxVars': // This op is currently ignored.\n            return [\n                utils_1.getParamValue('x', node, tensorMap, context).clone()\n            ];\n        case 'IdentityN':\n            return utils_1.getParamValue('x', node, tensorMap, context)\n                .map(function (t) { return t.clone(); });\n        case 'Snapshot':\n            var snapshot = utils_1.getParamValue('x', node, tensorMap, context);\n            return [snapshot.clone()];\n        case 'Shape':\n            return [tfc.tensor1d(utils_1.getParamValue('x', node, tensorMap, context).shape, 'int32')];\n        case 'ShapeN':\n            return utils_1.getParamValue('x', node, tensorMap, context)\n                .map(function (t) { return tfc.tensor1d(t.shape); });\n        case 'Size':\n            return [tfc.scalar(utils_1.getParamValue('x', node, tensorMap, context).size, 'int32')];\n        case 'Rank':\n            return [tfc.scalar(utils_1.getParamValue('x', node, tensorMap, context).rank, 'int32')];\n        case 'NoOp':\n            return [];\n        case 'Print':\n            var input = utils_1.getParamValue('x', node, tensorMap, context);\n            var data = utils_1.getParamValue('data', node, tensorMap, context);\n            var message = utils_1.getParamValue('message', node, tensorMap, context);\n            var summarize = utils_1.getParamValue('summarize', node, tensorMap, context);\n            console.warn('The graph has a tf.print() operation,' +\n                'usually used for debugging, which slows down performance.');\n            console.log(message);\n            for (var i = 0; i < data.length; i++) {\n                console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));\n            }\n            return [input];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'graph';\n//# sourceMappingURL=graph_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'ResizeBilinear': {\n            var images = utils_1.getParamValue('images', node, tensorMap, context);\n            var size = utils_1.getParamValue('size', node, tensorMap, context);\n            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);\n            return [tfc.image.resizeBilinear(images, [size[0], size[1]], alignCorners)];\n        }\n        case 'ResizeNearestNeighbor': {\n            var images = utils_1.getParamValue('images', node, tensorMap, context);\n            var size = utils_1.getParamValue('size', node, tensorMap, context);\n            var alignCorners = utils_1.getParamValue('alignCorners', node, tensorMap, context);\n            return [tfc.image.resizeNearestNeighbor(images, [size[0], size[1]], alignCorners)];\n        }\n        case 'CropAndResize': {\n            var image = utils_1.getParamValue('image', node, tensorMap, context);\n            var boxes = utils_1.getParamValue('boxes', node, tensorMap, context);\n            var boxInd = utils_1.getParamValue('boxInd', node, tensorMap, context);\n            var cropSize = utils_1.getParamValue('cropSize', node, tensorMap, context);\n            var method = utils_1.getParamValue('method', node, tensorMap, context);\n            var extrapolationValue = utils_1.getParamValue('extrapolationValue', node, tensorMap, context);\n            return [tfc.image.cropAndResize(image, boxes, boxInd, cropSize, method, extrapolationValue)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'image';\n//# sourceMappingURL=image_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Equal': {\n            return [tfc.equal(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'NotEqual': {\n            return [tfc.notEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Greater': {\n            return [tfc.greater(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'GreaterEqual': {\n            return [tfc.greaterEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Less': {\n            return [tfc.less(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LessEqual': {\n            return [tfc.lessEqual(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LogicalAnd': {\n            return [tfc.logicalAnd(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'LogicalNot': {\n            return [tfc.logicalNot(utils_1.getParamValue('a', node, tensorMap, context))];\n        }\n        case 'LogicalOr': {\n            return [tfc.logicalOr(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        case 'Select': {\n            return [tfc.where(utils_1.getParamValue('condition', node, tensorMap, context), utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'logical';\n//# sourceMappingURL=logical_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'BatchMatMul':\n        case 'MatMul':\n            return [tfc.matMul(utils_1.getParamValue('a', node, tensorMap, context), utils_1.getParamValue('b', node, tensorMap, context), utils_1.getParamValue('transposeA', node, tensorMap, context), utils_1.getParamValue('transposeB', node, tensorMap, context))];\n        case 'Transpose':\n            return [tfc.transpose(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('perm', node, tensorMap, context))];\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'matrices';\n//# sourceMappingURL=matrices_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'FusedBatchNorm':\n        case 'FusedBatchNormV2': {\n            return [tfc.batchNorm(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('epsilon', node, tensorMap, context))];\n        }\n        case 'FusedBatchNormV3': {\n            return [tfc.batchNorm(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('mean', node, tensorMap, context), utils_1.getParamValue('variance', node, tensorMap, context), utils_1.getParamValue('offset', node, tensorMap, context), utils_1.getParamValue('scale', node, tensorMap, context), utils_1.getParamValue('epsilon', node, tensorMap, context))];\n        }\n        case 'LRN': {\n            return [tfc.localResponseNormalization(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('radius', node, tensorMap, context), utils_1.getParamValue('bias', node, tensorMap, context), utils_1.getParamValue('alpha', node, tensorMap, context), utils_1.getParamValue('beta', node, tensorMap, context))];\n        }\n        case 'Softmax': {\n            return [tfc.softmax(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'LogSoftmax': {\n            return [tfc.logSoftmax(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'SparseToDense': {\n            return [tfc.sparseToDense(utils_1.getParamValue('sparseIndices', node, tensorMap, context), utils_1.getParamValue('outputShape', node, tensorMap, context), utils_1.getParamValue('sparseValues', node, tensorMap, context), utils_1.getParamValue('defaultValue', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'normalization';\n//# sourceMappingURL=normalization_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Max': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.max(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Mean': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.mean(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Min': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.min(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Sum': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.sum(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'All': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.all(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'Any': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.any(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        case 'ArgMax': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            return [tfc.argMax(utils_1.getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'ArgMin': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            return [tfc.argMin(utils_1.getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Prod': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var keepDims = utils_1.getParamValue('keepDims', node, tensorMap, context);\n            return [tfc.prod(utils_1.getParamValue('x', node, tensorMap, context), axis, keepDims)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'reduction';\n//# sourceMappingURL=reduction_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'ConcatV2':\n        case 'Concat': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var inputs = utils_1.getParamValue('tensors', node, tensorMap, context);\n            return [tfc.concat(inputs, axis)];\n        }\n        case 'GatherV2':\n        case 'Gather': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var input = utils_1.getParamValue('x', node, tensorMap, context);\n            var indices = utils_1.getParamValue('indices', node, tensorMap, context);\n            return [tfc.gather(input, indices.asType('int32'), axis)];\n        }\n        case 'ReverseV2':\n        case 'Reverse': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var input = utils_1.getParamValue('x', node, tensorMap, context);\n            return [tfc.reverse(input, axis)];\n        }\n        case 'Slice': {\n            // tslint:disable-next-line:no-any\n            var begin = utils_1.getParamValue('begin', node, tensorMap, context);\n            // tslint:disable-next-line:no-any\n            var size = utils_1.getParamValue('size', node, tensorMap, context);\n            return [tfc.slice(utils_1.getParamValue('x', node, tensorMap, context), begin, size)];\n        }\n        case 'StridedSlice': {\n            var begin = utils_1.getParamValue('begin', node, tensorMap, context);\n            var end = utils_1.getParamValue('end', node, tensorMap, context);\n            var strides = utils_1.getParamValue('strides', node, tensorMap, context);\n            var beginMask = utils_1.getParamValue('beginMask', node, tensorMap, context);\n            var endMask = utils_1.getParamValue('endMask', node, tensorMap, context);\n            var ellipsisMask = utils_1.getParamValue('ellipsisMask', node, tensorMap, context);\n            var newAxisMask = utils_1.getParamValue('newAxisMask', node, tensorMap, context);\n            var shrinkAxisMask = utils_1.getParamValue('shrinkAxisMask', node, tensorMap, context);\n            var tensor = utils_1.getParamValue('x', node, tensorMap, context);\n            if (begin.length === 1 && tensor.shape.length > 1) {\n                for (var i = 1; i < tensor.shape.length; i++) {\n                    begin.push(0);\n                    end.push(tensor.shape[i]);\n                    strides.push(strides[0]);\n                }\n            }\n            return [tfc.stridedSlice(tensor, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask)];\n        }\n        case 'Pack': {\n            return tfc.tidy(function () {\n                var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n                var tensors = utils_1.getParamValue('tensors', node, tensorMap, context);\n                // Reshape the tensors to the first tensor's shape if they don't match.\n                var shape = tensors[0].shape;\n                var squeezedShape = tensors[0].squeeze().shape;\n                var mapped = tensors.map(function (tensor) {\n                    var sameShape = tfc.util.arraysEqual(tensor.shape, shape);\n                    if (!sameShape &&\n                        !tfc.util.arraysEqual(tensor.squeeze().shape, squeezedShape)) {\n                        throw new Error('the input tensors shape does not match');\n                    }\n                    return sameShape ? tensor : tensor.reshape(shape);\n                });\n                return [tfc.stack(mapped, axis)];\n            });\n        }\n        case 'Unpack': {\n            return tfc.tidy(function () {\n                var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n                var tensor = utils_1.getParamValue('tensor', node, tensorMap, context);\n                return tfc.unstack(tensor, axis);\n            });\n        }\n        case 'Tile': {\n            var reps = utils_1.getParamValue('reps', node, tensorMap, context);\n            return [tfc.tile(utils_1.getParamValue('x', node, tensorMap, context), reps)];\n        }\n        case 'Split':\n        case 'SplitV': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            var numOrSizeSplits = utils_1.getParamValue('numOrSizeSplits', node, tensorMap, context);\n            return tfc.split(utils_1.getParamValue('x', node, tensorMap, context), numOrSizeSplits, axis);\n        }\n        case 'ScatterNd': {\n            var indices = utils_1.getParamValue('indices', node, tensorMap, context);\n            var values = utils_1.getParamValue('values', node, tensorMap, context);\n            var shape = utils_1.getParamValue('shape', node, tensorMap, context);\n            return [tfc.scatterND(indices, values, shape)];\n        }\n        case 'GatherNd': {\n            var x = utils_1.getParamValue('x', node, tensorMap, context);\n            var indices = utils_1.getParamValue('indices', node, tensorMap, context);\n            return [tfc.gatherND(x, indices)];\n        }\n        case 'SparseToDense': {\n            var indices = utils_1.getParamValue('sparseIndices', node, tensorMap, context);\n            var shape = utils_1.getParamValue('outputShape', node, tensorMap, context);\n            var sparseValues = utils_1.getParamValue('sparseValues', node, tensorMap, context);\n            var defaultValue = utils_1.getParamValue('defaultValue', node, tensorMap, context);\n            return [tfc.sparseToDense(indices, sparseValues, shape, sparseValues.dtype === defaultValue.dtype ?\n                    defaultValue :\n                    defaultValue.asType(sparseValues.dtype))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'slice_join';\n//# sourceMappingURL=slice_join_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'FFT': {\n            return [tfc.fft(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'IFFT': {\n            return [tfc.ifft(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'RFFT': {\n            return [tfc.rfft(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        case 'IRFFT': {\n            return [tfc.irfft(utils_1.getParamValue('x', node, tensorMap, context))];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'spectral';\n//# sourceMappingURL=spectral_executor.js.map","\n/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tfc = require(\"@tensorflow/tfjs-core\");\nvar utils_1 = require(\"./utils\");\nexports.executeOp = function (node, tensorMap, context) {\n    switch (node.op) {\n        case 'Cast': {\n            return [tfc.cast(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('dtype', node, tensorMap, context))];\n        }\n        case 'ExpandDims': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            return [tfc.expandDims(utils_1.getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Squeeze': {\n            var axis = utils_1.getParamValue('axis', node, tensorMap, context);\n            return [tfc.squeeze(utils_1.getParamValue('x', node, tensorMap, context), axis)];\n        }\n        case 'Reshape': {\n            return [tfc.reshape(utils_1.getParamValue('x', node, tensorMap, context), utils_1.getParamValue('shape', node, tensorMap, context))];\n        }\n        case 'PadV2':\n        case 'Pad': {\n            return [tfc.pad(utils_1.getParamValue('x', node, tensorMap, context), utils_1.split(utils_1.getParamValue('padding', node, tensorMap, context), 2), utils_1.getParamValue('constantValue', node, tensorMap, context))];\n        }\n        case 'SpaceToBatchND': {\n            var blockShape = utils_1.getParamValue('blockShape', node, tensorMap, context);\n            var paddings = utils_1.split(utils_1.getParamValue('paddings', node, tensorMap, context), 2);\n            return [tfc.spaceToBatchND(utils_1.getParamValue('x', node, tensorMap, context), blockShape, paddings)];\n        }\n        case 'BatchToSpaceND': {\n            var blockShape = utils_1.getParamValue('blockShape', node, tensorMap, context);\n            var crops = utils_1.split(utils_1.getParamValue('crops', node, tensorMap, context), 2);\n            return [tfc.batchToSpaceND(utils_1.getParamValue('x', node, tensorMap, context), blockShape, crops)];\n        }\n        case 'DepthToSpace': {\n            var blockSize = utils_1.getParamValue('blockSize', node, tensorMap, context);\n            var dataFormat = utils_1.getParamValue('dataFormat', node, tensorMap, context).toUpperCase();\n            return [tfc.depthToSpace(utils_1.getParamValue('x', node, tensorMap, context), blockSize, dataFormat)];\n        }\n        default:\n            throw TypeError(\"Node type \" + node.op + \" is not implemented\");\n    }\n};\nexports.CATEGORY = 'transformation';\n//# sourceMappingURL=transformation_executor.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * ExecutionContext captures the runtime environment of the node. It keeps\n * track of the current frame and iteration for the control flow ops.\n *\n * For example, typical Dynamic RNN model may contain loops, for which\n * TensorFlow will generate graphs with Enter/Exit nodes to control the\n * current execution frame, and NextIteration Nodes for iteration id increment.\n * For model with branch logic, TensorFLow will generate Switch/Merge ops.\n */\nvar ExecutionContext = /** @class */ (function () {\n    function ExecutionContext(weightMap, tensorArrayMap) {\n        this.weightMap = weightMap;\n        this.tensorArrayMap = tensorArrayMap;\n        this.rootContext = { id: 0, frameName: '', iterationId: 0 };\n        this.contexts = [this.rootContext];\n        this.lastId = 0;\n        this.generateCurrentContextIds();\n    }\n    ExecutionContext.prototype.newFrame = function (id, frameName) {\n        return { id: id, frameName: frameName, iterationId: 0 };\n    };\n    Object.defineProperty(ExecutionContext.prototype, \"currentContext\", {\n        get: function () {\n            return this.contexts;\n        },\n        /**\n         * Set the current context\n         * @param contexts: ExecutionContextInfo[] the current path of execution\n         * frames\n         */\n        set: function (contexts) {\n            if (this.contexts !== contexts) {\n                this.contexts = contexts;\n                this.generateCurrentContextIds();\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExecutionContext.prototype, \"currentContextId\", {\n        /**\n         * Returns the current context in string format.\n         */\n        get: function () {\n            return this._currentContextIds[0];\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(ExecutionContext.prototype, \"currentContextIds\", {\n        /**\n         * Returns the current context and all parent contexts in string format.\n         * This allow access to the nodes in the current and parent frames.\n         */\n        get: function () {\n            return this._currentContextIds;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ExecutionContext.prototype.generateCurrentContextIds = function () {\n        var names = [];\n        for (var i = 0; i < this.contexts.length - 1; i++) {\n            var contexts = this.contexts.slice(0, this.contexts.length - i);\n            names.push(this.contextIdforContexts(contexts));\n        }\n        names.push('');\n        this._currentContextIds = names;\n    };\n    ExecutionContext.prototype.contextIdforContexts = function (contexts) {\n        return contexts ?\n            contexts\n                .map(function (context) { return (context.id === 0 && context.iterationId === 0) ?\n                '' :\n                context.frameName + \"-\" + context.iterationId; })\n                .join('/') :\n            '';\n    };\n    /**\n     * Enter a new frame, a new context is pushed on the current context list.\n     * @param frameId new frame id\n     */\n    ExecutionContext.prototype.enterFrame = function (frameId) {\n        if (this.contexts) {\n            this.lastId++;\n            this.contexts = this.contexts.slice();\n            this.contexts.push(this.newFrame(this.lastId, frameId));\n            this._currentContextIds.unshift(this.contextIdforContexts(this.contexts));\n        }\n    };\n    /**\n     * Exit the current frame, the last context is removed from the current\n     * context list.\n     */\n    ExecutionContext.prototype.exitFrame = function () {\n        if (this.contexts && this.contexts.length > 1) {\n            this.contexts = this.contexts.slice();\n            this.contexts.splice(-1);\n            this.currentContextIds.shift();\n        }\n        else {\n            throw new Error('Cannot exit frame, the context is empty');\n        }\n    };\n    /**\n     * Enter the next iteration of a loop, the iteration id of last context is\n     * increased.\n     */\n    ExecutionContext.prototype.nextIteration = function () {\n        if (this.contexts && this.contexts.length > 0) {\n            this.contexts = this.contexts.slice();\n            this.lastId++;\n            var context = Object.assign({}, this.contexts[this.contexts.length - 1]);\n            context.iterationId += 1;\n            context.id = this.lastId;\n            this.contexts.splice(-1, 1, context);\n            this._currentContextIds.splice(0, 1, this.contextIdforContexts(this.contexts));\n        }\n        else {\n            throw new Error('Cannot increase frame iteration, the context is empty');\n        }\n    };\n    ExecutionContext.prototype.getWeight = function (name) {\n        return this.weightMap[name];\n    };\n    ExecutionContext.prototype.addTensorArray = function (tensorArray) {\n        this.tensorArrayMap[tensorArray.id] = tensorArray;\n    };\n    ExecutionContext.prototype.getTensorArray = function (id) {\n        return this.tensorArrayMap[id];\n    };\n    return ExecutionContext;\n}());\nexports.ExecutionContext = ExecutionContext;\n//# sourceMappingURL=execution_context.js.map","\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nfunction getExecutionSubgraph(inputs, outputs, weightMap) {\n    var usedNodes = new Set();\n    var missingInputs = [];\n    var dynamicNode = null;\n    var syncInputs = null;\n    // Start with the outputs, going backwards and find all the nodes that are\n    // needed to compute those outputs.\n    var seen = new Set();\n    var frontier = outputs.slice();\n    while (frontier.length > 0) {\n        var node = frontier.pop();\n        if (isControlFlow(node) || isDynamicShape(node)) {\n            if (dynamicNode == null) {\n                dynamicNode = node;\n                syncInputs = dynamicNode.children.map(function (child) { return child.name; })\n                    .filter(function (name) { return usedNodes.has(name); });\n            }\n        }\n        usedNodes.add(node.name);\n        // Weights are dead end since we already have their values.\n        if (weightMap[node.name] != null) {\n            continue;\n        }\n        // This node is a dead end since it's one of the user-provided inputs.\n        if (inputs[node.name] != null) {\n            continue;\n        }\n        if (node.inputs.length === 0) {\n            missingInputs.push(node.name);\n            continue;\n        }\n        node.inputs.forEach(function (input) {\n            // Don't add to the frontier if it is already there.\n            if (seen.has(input.name)) {\n                return;\n            }\n            seen.add(input.name);\n            frontier.push(input);\n        });\n    }\n    return { inputs: inputs, outputs: outputs, usedNodes: usedNodes, missingInputs: missingInputs, dynamicNode: dynamicNode, syncInputs: syncInputs };\n}\nexports.getExecutionSubgraph = getExecutionSubgraph;\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nfunction getNodesInTopologicalOrder(graph, weightMap, executionInfo) {\n    var usedNodes = executionInfo.usedNodes, inputs = executionInfo.inputs;\n    var frontier = [];\n    var inputNodes = Object.keys(inputs).map(function (name) { return graph.nodes[name]; });\n    inputNodes.forEach(function (input) {\n        if (usedNodes.has(input.name)) {\n            frontier.push(input);\n        }\n    });\n    graph.weights.forEach(function (weight) {\n        if (usedNodes.has(weight.name)) {\n            frontier.push(weight);\n        }\n    });\n    var seen = new Set();\n    var orderedNodes = [];\n    while (frontier.length > 0) {\n        var node = frontier.pop();\n        seen.add(node.name);\n        if (!weightMap[node.name]) {\n            orderedNodes.push(node);\n        }\n        node.children.forEach(function (child) {\n            if (!seen.has(child.name) && usedNodes.has(child.name) &&\n                child.inputs.every(function (input) { return seen.has(input.name); })) {\n                frontier.push(child);\n            }\n        });\n    }\n    return orderedNodes;\n}\nexports.getNodesInTopologicalOrder = getNodesInTopologicalOrder;\nvar CONTROL_FLOW_OPS = ['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration'];\nvar DYNAMIC_SHAPE_OPS = ['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'Where'];\nfunction isControlFlow(node) {\n    return CONTROL_FLOW_OPS.indexOf(node.op) >= 0;\n}\nexports.isControlFlow = isControlFlow;\nfunction isDynamicShape(node) {\n    return DYNAMIC_SHAPE_OPS.indexOf(node.op) >= 0;\n}\nexports.isDynamicShape = isDynamicShape;\n//# sourceMappingURL=model_analysis.js.map","\n/** @license See the LICENSE file. */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// This code is auto-generated, do not modify this file!\nvar version = '1.2.2';\nexports.version = version;\n//# sourceMappingURL=version.js.map"]}